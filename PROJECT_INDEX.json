{
  "indexed_at": "2025-08-19T09:43:01.539086",
  "root": ".",
  "project_structure": {
    "type": "tree",
    "root": ".",
    "tree": [
      ".",
      "\u251c\u2500\u2500 docs/",
      "\u251c\u2500\u2500 examples/ (33 files)",
      "\u2502   \u251c\u2500\u2500 lerna_example/ (7 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 apps/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 api/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 web/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 packages/ (3 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 core/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 ui/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 package.json",
      "\u2502   \u2502   \u2514\u2500\u2500 README.md",
      "\u2502   \u251c\u2500\u2500 manual_config_example/ (10 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 backend/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 api/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 auth/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 frontend/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 mobile/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 web/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 shared/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 types/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 tools/ (2 files)",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 cli/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 package.json",
      "\u2502   \u2502   \u2514\u2500\u2500 README.md",
      "\u2502   \u251c\u2500\u2500 nx_example/ (7 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 apps/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 admin/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 mobile/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 packages/ (3 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 api/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 shared/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 web/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 package.json",
      "\u2502   \u2502   \u2514\u2500\u2500 README.md",
      "\u2502   \u251c\u2500\u2500 pnpm_example/ (9 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 apps/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboard/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 frontend/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 packages/ (3 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 common/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 database/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 services/ (2 files)",
      "\u2502   \u2502   \u2502   \u251c\u2500\u2500 api/ (1 files)",
      "\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u2502   \u2514\u2500\u2500 worker/ (1 files)",
      "\u2502   \u2502   \u2502       \u251c\u2500\u2500 src/",
      "\u2502   \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502   \u2502   \u251c\u2500\u2500 package.json",
      "\u2502   \u2502   \u2514\u2500\u2500 README.md",
      "\u2502   \u251c\u2500\u2500 rush_example/",
      "\u2502   \u2514\u2500\u2500 yarn_example/",
      "\u251c\u2500\u2500 scripts/ (23 files)",
      "\u251c\u2500\u2500 tests/ (35 files)",
      "\u2502   \u2514\u2500\u2500 fixtures/ (19 files)",
      "\u2502       \u251c\u2500\u2500 lerna_monorepo/ (4 files)",
      "\u2502       \u2502   \u251c\u2500\u2500 packages/ (1 files)",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 api/ (1 files)",
      "\u2502       \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 utils/",
      "\u2502       \u2502   \u2502   \u2514\u2500\u2500 web/",
      "\u2502       \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u251c\u2500\u2500 manual_config/ (2 files)",
      "\u2502       \u2502   \u251c\u2500\u2500 projects/ (1 files)",
      "\u2502       \u2502   \u2502   \u2514\u2500\u2500 app/ (1 files)",
      "\u2502       \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502       \u2502   \u2514\u2500\u2500 {projects/",
      "\u2502       \u2502       \u251c\u2500\u2500 app}/",
      "\u2502       \u2502       \u251c\u2500\u2500 lib}/",
      "\u2502       \u2502       \u2514\u2500\u2500 tools}/",
      "\u2502       \u251c\u2500\u2500 nx_monorepo/ (7 files)",
      "\u2502       \u2502   \u251c\u2500\u2500 apps/",
      "\u2502       \u2502   \u251c\u2500\u2500 libs/",
      "\u2502       \u2502   \u2514\u2500\u2500 packages/ (5 files)",
      "\u2502       \u2502       \u251c\u2500\u2500 api/ (2 files)",
      "\u2502       \u2502       \u2502   \u251c\u2500\u2500 src/ (1 files)",
      "\u2502       \u2502       \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u2502       \u251c\u2500\u2500 shared/ (2 files)",
      "\u2502       \u2502       \u2502   \u251c\u2500\u2500 src/ (1 files)",
      "\u2502       \u2502       \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u2502       \u2514\u2500\u2500 web/ (1 files)",
      "\u2502       \u2502           \u2514\u2500\u2500 package.json",
      "\u2502       \u251c\u2500\u2500 pnpm_workspaces/ (2 files)",
      "\u2502       \u2502   \u251c\u2500\u2500 packages/ (1 files)",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 core/ (1 files)",
      "\u2502       \u2502   \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 ui/",
      "\u2502       \u2502   \u2502   \u2514\u2500\u2500 utils/",
      "\u2502       \u2502   \u251c\u2500\u2500 services/",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 api/",
      "\u2502       \u2502   \u2502   \u2514\u2500\u2500 auth/",
      "\u2502       \u2502   \u2514\u2500\u2500 package.json",
      "\u2502       \u251c\u2500\u2500 rush_monorepo/ (2 files)",
      "\u2502       \u2502   \u251c\u2500\u2500 apps/ (1 files)",
      "\u2502       \u2502   \u2502   \u251c\u2500\u2500 admin/",
      "\u2502       \u2502   \u2502   \u2514\u2500\u2500 website/ (1 files)",
      "\u2502       \u2502   \u2502       \u2514\u2500\u2500 package.json",
      "\u2502       \u2502   \u2514\u2500\u2500 libraries/",
      "\u2502       \u2502       \u251c\u2500\u2500 shared-utils/",
      "\u2502       \u2502       \u2514\u2500\u2500 ui-components/",
      "\u2502       \u2514\u2500\u2500 yarn_workspaces/ (2 files)",
      "\u2502           \u251c\u2500\u2500 apps/",
      "\u2502           \u2502   \u251c\u2500\u2500 mobile-app/",
      "\u2502           \u2502   \u2514\u2500\u2500 web-app/",
      "\u2502           \u251c\u2500\u2500 packages/ (1 files)",
      "\u2502           \u2502   \u251c\u2500\u2500 backend/",
      "\u2502           \u2502   \u251c\u2500\u2500 frontend/ (1 files)",
      "\u2502           \u2502   \u2502   \u2514\u2500\u2500 package.json",
      "\u2502           \u2502   \u2514\u2500\u2500 shared/",
      "\u2502           \u2514\u2500\u2500 package.json",
      "\u2514\u2500\u2500 README.md"
    ]
  },
  "documentation_map": {
    "MONOREPO_MCD.md": {
      "sections": [
        "Monorepo Support MCD (Main Context Document)",
        "\ud83c\udfaf Overview & Goals",
        "Project Vision",
        "Target Users",
        "Core Features",
        "Success Criteria",
        "Business Context",
        "\ud83c\udfd7\ufe0f Technical Architecture",
        "Hierarchical Index Architecture (Option A)",
        "\ud83d\udccb Detailed Implementation"
      ],
      "architecture_hints": []
    },
    "README.md": {
      "sections": [
        "Project Index for Claude Code (v0.1.0)",
        "\ud83c\udf1f New in v0.1.0: Complete Monorepo Support",
        "\ud83d\ude80 Quick Install",
        "\ud83d\udcd6 Usage",
        "Create an Index for Your Project",
        "Using the Index",
        "Ask architectural questions",
        "Or auto-load in every session by adding to CLAUDE.md:",
        "Add @PROJECT_INDEX.json to your CLAUDE.md file",
        "\ud83d\udce6 Updating"
      ],
      "architecture_hints": []
    },
    "LIGHTWEIGHT_ROOT_INDEX_MCD.md": {
      "sections": [
        "Lightweight Root Index Architecture MCD (Main Context Document)",
        "\ud83c\udfaf Overview & Goals",
        "Project Vision",
        "Target Users",
        "Core Features",
        "Success Criteria",
        "Business Context",
        "\ud83c\udfd7\ufe0f Technical Architecture",
        "Current Architecture Issues",
        "Proposed Hierarchical Architecture"
      ],
      "architecture_hints": []
    },
    "docs/configuration-reference.md": {
      "sections": [
        "Configuration Reference",
        "Configuration Files",
        "Manual Configuration File",
        "Global Configuration Options",
        "Basic Settings",
        "Performance Settings",
        "Analysis Settings",
        "Workspace Configuration",
        "Workspace Options",
        "Performance Modes"
      ],
      "architecture_hints": []
    },
    "docs/monorepo-setup.md": {
      "sections": [
        "Monorepo Setup Guide",
        "Quick Start",
        "Install the project indexer",
        "Index your monorepo (automatic detection)",
        "Supported Monorepo Tools",
        "Nx Monorepo",
        "1. Ensure nx.json exists with project configurations",
        "Should contain projects configuration",
        "2. Run indexing",
        "3. Verify detection"
      ],
      "architecture_hints": []
    },
    "docs/performance-guide.md": {
      "sections": [
        "Performance Guide",
        "Performance Targets",
        "Performance Modes",
        "Overview",
        "Fast Mode",
        "Balanced Mode (Default)",
        "Comprehensive Mode",
        "Optimization Strategies",
        "1. Ignore Pattern Optimization",
        "2. Parallel Processing Optimization"
      ],
      "architecture_hints": []
    },
    "docs/troubleshooting.md": {
      "sections": [
        "Troubleshooting Guide",
        "Quick Diagnostics",
        "Check basic system health",
        "Validate configuration",
        "Test workspace detection",
        "Performance check",
        "Common Issues and Solutions",
        "1. Monorepo Not Detected",
        "Check for configuration files",
        "Test detection manually"
      ],
      "architecture_hints": []
    },
    "docs/migration-guide.md": {
      "sections": [
        "Migration Guide: Single-Repo to Monorepo",
        "Overview",
        "Pre-Migration Checklist",
        "Migration Scenarios",
        "Scenario 1: Existing Monorepo, No Index",
        "1. Install Project Index",
        "2. Run automatic detection",
        "3. Verify monorepo detection",
        "4. Add to CLAUDE.md",
        "Scenario 2: Single Repo \u2192 Monorepo Conversion"
      ],
      "architecture_hints": []
    },
    "docs/api-reference.md": {
      "sections": [
        "API Reference",
        "Core Modules",
        "`monorepo_detector.py`",
        "`workspace_config.py`",
        "`workspace_indexer.py`"
      ],
      "architecture_hints": []
    },
    "examples/nx_example/README.md": {
      "sections": [
        "Nx Monorepo Example",
        "Structure",
        "Workspaces",
        "Dependencies",
        "Setup Instructions",
        "Expected Output",
        "Commands",
        "Index specific workspace",
        "View dependencies",
        "Performance check"
      ],
      "architecture_hints": []
    },
    "examples/lerna_example/README.md": {
      "sections": [
        "Lerna Monorepo Example",
        "Structure",
        "Workspaces",
        "Packages (Published)",
        "Apps (Private)",
        "Key Features",
        "Setup Instructions",
        "Expected Output",
        "Lerna Commands",
        "Development Workflow"
      ],
      "architecture_hints": []
    },
    "examples/manual_config_example/README.md": {
      "sections": [
        "Manual Configuration Example",
        "Structure",
        "Key Features",
        "Manual Workspace Configuration",
        "Advanced Configuration Options",
        "Multi-Language Support",
        "Workspaces",
        "Backend Services",
        "Frontend Applications  ",
        "Shared Libraries"
      ],
      "architecture_hints": []
    },
    "examples/pnpm_example/README.md": {
      "sections": [
        "PNPM Workspace Example",
        "Structure",
        "Workspaces",
        "Packages (Published)",
        "Services (Private)",
        "Apps (Private)",
        "Key PNPM Features Demonstrated",
        "Dependency Catalog",
        "Workspace Protocol",
        "Filtering and Targeting"
      ],
      "architecture_hints": []
    }
  },
  "directory_purposes": {
    "scripts": "Build and utility scripts",
    "docs": "Project documentation",
    "examples/manual_config_example": "Configuration files and settings",
    "examples/pnpm_example/packages/auth": "Authentication and authorization logic",
    "examples/pnpm_example/services/api": "API endpoints and route handlers",
    "examples/manual_config_example/backend/api": "API endpoints and route handlers",
    "examples/manual_config_example/backend/auth": "Authentication and authorization logic",
    "examples/manual_config_example/shared/utils": "Shared utility functions and helpers",
    "examples/lerna_example/packages/utils": "Shared utility functions and helpers",
    "examples/lerna_example/apps/api": "API endpoints and route handlers",
    "examples/nx_example/packages/api": "API endpoints and route handlers",
    "tests/fixtures/manual_config": "Configuration files and settings",
    "tests/fixtures/lerna_monorepo/packages/api": "API endpoints and route handlers",
    "tests/fixtures/nx_monorepo/packages/api": "API endpoints and route handlers",
    "tests/fixtures/nx_monorepo/packages/api/src": "Source code root directory",
    "tests/fixtures/nx_monorepo/packages/shared/src": "Source code root directory"
  },
  "stats": {
    "total_files": 78,
    "total_directories": 121,
    "fully_parsed": {
      "python": 18,
      "shell": 1,
      "typescript": 2
    },
    "listed_only": {
      "shell": 4,
      "json": 53
    },
    "markdown_files": 13
  },
  "files": {
    "install.sh": {
      "language": "shell",
      "parsed": false
    },
    ".mcp.json": {
      "language": "json",
      "parsed": false
    },
    "uninstall.sh": {
      "language": "shell",
      "parsed": false
    },
    "run_coverage.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "sys",
        "subprocess",
        "time",
        "pathlib"
      ],
      "functions": {
        "run_test_file": {
          "doc": "Run a single test file and return results.",
          "signature": "(test_file)",
          "called_by": [
            "main"
          ]
        },
        "main": {
          "doc": "Run all test files and summarize results.",
          "calls": [
            "run_test_file"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    ".agent/config.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    ".claude/settings.local.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    "scripts/reindex_if_needed_enhanced.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "subprocess",
        "time",
        "pathlib",
        "datetime",
        "typing",
        "workspace_config",
        "workspace_indexer"
      ],
      "functions": {
        "find_project_modules": {
          "doc": "Find project modules in project or system location.",
          "signature": "()"
        },
        "get_workspace_config_cached": {
          "doc": "Get workspace configuration with caching.",
          "signature": "(project_root: Path) -> Optional[Dict]",
          "called_by": [
            "check_workspace_staleness",
            "check_workspace_configuration_changes",
            "run_workspace_reindex",
            "run_reindex",
            "update_root_index_after_workspace_reindex",
            "main",
            "get_workspace_for_file",
            "get_workspace_index_path",
            "get_dependent_workspaces",
            "update_root_index_workspace_registry",
            "handle_file_update",
            "check_workspace_staleness",
            "check_workspace_configuration_changes",
            "run_workspace_reindex",
            "run_reindex",
            "update_root_index_after_workspace_reindex",
            "main",
            "get_workspace_for_file",
            "get_workspace_index_path",
            "get_dependent_workspaces",
            "handle_cross_workspace_dependencies",
            "update_root_index_workspace_registry",
            "detect_file_move",
            "handle_file_update"
          ]
        },
        "check_index_features": {
          "doc": "Check if index has all required features.",
          "signature": "(index_path: Path) -> Tuple[bool, Optional[str]]",
          "called_by": [
            "check_workspace_staleness",
            "handle_single_repo_reindex",
            "check_workspace_staleness",
            "handle_single_repo_reindex"
          ]
        },
        "check_index_staleness": {
          "doc": "Check if index is older than threshold.",
          "signature": "(index_path: Path, threshold_hours: int = 24) -> bool",
          "called_by": [
            "check_workspace_staleness",
            "handle_single_repo_reindex",
            "check_workspace_staleness",
            "handle_single_repo_reindex"
          ]
        },
        "check_workspace_staleness": {
          "doc": "Check if a specific workspace is stale.",
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> Tuple[bool, Optional[str]]",
          "called_by": [
            "handle_workspace_aware_reindex",
            "handle_workspace_aware_reindex"
          ]
        },
        "check_missing_documentation": {
          "doc": "Check if important documentation files are missing from index.",
          "signature": "(index_path: Path, workspace_root: Path) -> bool",
          "called_by": [
            "check_workspace_staleness",
            "handle_single_repo_reindex",
            "check_workspace_staleness",
            "handle_single_repo_reindex"
          ]
        },
        "check_structural_changes": {
          "doc": "Check if directory structure has significantly changed.",
          "signature": "(index_path: Path, workspace_root: Path) -> bool",
          "called_by": [
            "check_workspace_staleness",
            "handle_single_repo_reindex",
            "check_workspace_staleness",
            "handle_single_repo_reindex"
          ]
        },
        "count_hook_updates": {
          "doc": "Count how many files were updated by hooks vs full index.",
          "signature": "(index_path: Path) -> Tuple[int, int]",
          "called_by": [
            "check_workspace_staleness",
            "handle_single_repo_reindex",
            "check_workspace_staleness",
            "handle_single_repo_reindex"
          ]
        },
        "check_workspace_configuration_changes": {
          "doc": "Check if workspace configuration has changed.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(project_root: Path) -> Tuple[bool, List[str]]",
          "called_by": [
            "handle_workspace_aware_reindex",
            "handle_workspace_aware_reindex"
          ]
        },
        "run_workspace_reindex": {
          "doc": "Run reindex for a specific workspace.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> bool",
          "called_by": [
            "run_reindex",
            "run_reindex"
          ]
        },
        "run_reindex": {
          "doc": "Run reindexing with workspace awareness.",
          "calls": [
            "get_workspace_config_cached",
            "run_reindex",
            "run_single_repo_reindex",
            "run_workspace_reindex",
            "update_root_index_after_workspace_reindex"
          ],
          "signature": "(project_root: Path, selective_workspaces: Optional[List[str]] = None) -> bool",
          "called_by": [
            "run_reindex",
            "handle_workspace_aware_reindex",
            "run_reindex",
            "handle_workspace_aware_reindex"
          ]
        },
        "run_single_repo_reindex": {
          "doc": "Run traditional single-repo reindex.",
          "signature": "(project_root: Path) -> bool",
          "called_by": [
            "run_reindex",
            "handle_single_repo_reindex",
            "run_reindex",
            "handle_single_repo_reindex"
          ]
        },
        "update_root_index_after_workspace_reindex": {
          "doc": "Update root index after workspace reindexing.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(project_root: Path, reindexed_workspaces: List[str]) -> None",
          "called_by": [
            "run_reindex",
            "run_reindex"
          ]
        },
        "main": {
          "doc": "Main hook entry point with workspace awareness.",
          "calls": [
            "get_workspace_config_cached",
            "handle_single_repo_reindex",
            "handle_workspace_aware_reindex"
          ],
          "signature": "()"
        },
        "handle_single_repo_reindex": {
          "doc": "Handle single-repo reindexing logic.",
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "run_single_repo_reindex"
          ],
          "signature": "(root_index_path: Path, project_root: Path) -> None",
          "called_by": [
            "main",
            "main"
          ]
        },
        "handle_workspace_aware_reindex": {
          "doc": "Handle workspace-aware reindexing logic.",
          "calls": [
            "check_workspace_configuration_changes",
            "check_workspace_staleness",
            "run_reindex"
          ],
          "signature": "(project_root: Path, workspace_config: Dict) -> None",
          "called_by": [
            "main",
            "main"
          ]
        }
      },
      "classes": {},
      "constants": {
        "CACHE_TTL": "number"
      },
      "call_graph": {}
    },
    "scripts/cross_workspace_analyzer.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "build_cross_workspace_dependencies": {
          "calls": [
            "analyze_all_workspaces"
          ],
          "signature": "(registry: WorkspaceRegistry, hierarchical_manager: Optional['HierarchicalIndexManager'] = None, for_root_index: bool = False, lazy_loader: Optional['LazyIndexLoader'] = None, compressor: Optional['SmartCompressor'] = None) -> Dict[str, Dict]"
        }
      },
      "classes": {
        "ImportInfo": {
          "methods": {
            "__post_init__": "(self)"
          },
          "decorators": [
            "dataclass"
          ],
          "doc": "Information about a cross-workspace import.",
          "properties": [
            "source_workspace",
            "target_workspace",
            "source_file",
            "import_statement",
            "import_type",
            "shared_types"
          ]
        },
        "CircularDependency": {
          "methods": {},
          "decorators": [
            "dataclass"
          ],
          "doc": "Information about a circular dependency.",
          "properties": [
            "cycle",
            "imports",
            "severity"
          ]
        },
        "CrossWorkspaceAnalyzer": {
          "methods": {
            "__init__": {
              "calls": [
                "_load_typescript_references",
                "_load_workspace_packages"
              ],
              "signature": "(self, registry: WorkspaceRegistry, hierarchical_manager: Optional['HierarchicalIndexManager'] = None, lazy_loader: Optional['LazyIndexLoader'] = None, compressor: Optional['SmartCompressor'] = None)"
            },
            "_load_workspace_packages": {
              "doc": "Load package.json from each workspace to understand package names and dependencies.",
              "signature": "(self) -> Dict[str, Dict]"
            },
            "_load_typescript_references": {
              "doc": "Load TypeScript project references from tsconfig.json files.",
              "signature": "(self) -> Dict[str, List[str]]"
            },
            "analyze_all_workspaces": {
              "calls": [
                "_analyze_workspace_imports",
                "_build_bidirectional_relationships",
                "_build_dependency_graph",
                "_detect_circular_dependencies",
                "_extract_shared_types",
                "_prepare_comprehensive_data",
                "_prepare_root_index_data"
              ],
              "signature": "(self, for_root_index: bool = False) -> Dict[str, Dict]"
            },
            "_analyze_workspace_imports": {
              "doc": "Analyze all imports in a workspace for cross-workspace dependencies with caching.",
              "calls": [
                "_analyze_file_imports",
                "_analyze_package_dependencies",
                "_get_cached_workspace_imports"
              ],
              "signature": "(self, workspace: WorkspaceConfig) -> List[ImportInfo]"
            },
            "_analyze_file_imports": {
              "doc": "Analyze imports in a single file.",
              "calls": [
                "_analyze_javascript_imports",
                "_analyze_python_imports"
              ],
              "signature": "(self, file_path: Path, workspace: WorkspaceConfig) -> List[ImportInfo]"
            },
            "_analyze_python_imports": {
              "doc": "Analyze Python imports for cross-workspace dependencies with AST parsing.",
              "calls": [
                "_analyze_python_imports_regex",
                "_extract_python_types_from_import",
                "_filter_type_names",
                "_resolve_python_import"
              ],
              "signature": "(self, content: str, workspace: WorkspaceConfig, file_path: str) -> List[ImportInfo]"
            },
            "_analyze_python_imports_regex": {
              "doc": "Fallback regex-based Python import analysis.",
              "calls": [
                "_filter_type_names",
                "_resolve_python_import"
              ],
              "signature": "(self, content: str, workspace: WorkspaceConfig, file_path: str) -> List[ImportInfo]"
            },
            "_analyze_javascript_imports": {
              "doc": "Analyze JavaScript/TypeScript imports for cross-workspace dependencies.",
              "calls": [
                "_filter_type_names",
                "_resolve_javascript_import"
              ],
              "signature": "(self, content: str, workspace: WorkspaceConfig, file_path: str) -> List[ImportInfo]"
            },
            "_resolve_python_import": {
              "doc": "Resolve a Python import to a workspace name.",
              "calls": [
                "_resolve_relative_python_import"
              ],
              "signature": "(self, import_path: str, workspace: WorkspaceConfig) -> Optional[str]"
            },
            "_resolve_javascript_import": {
              "doc": "Resolve a JavaScript/TypeScript import to a workspace name and import type.",
              "calls": [
                "_resolve_relative_javascript_import"
              ],
              "signature": "(self, import_path: str, workspace: WorkspaceConfig) -> Tuple[Optional[str], str]"
            },
            "_resolve_relative_python_import": {
              "doc": "Resolve relative Python imports that might cross workspace boundaries.",
              "signature": "(self, import_path: str, workspace: WorkspaceConfig) -> Optional[str]"
            },
            "_resolve_relative_javascript_import": {
              "doc": "Resolve relative JavaScript/TypeScript imports that might cross workspace boundaries.",
              "signature": "(self, import_path: str, workspace: WorkspaceConfig) -> Tuple[Optional[str], str]"
            },
            "_analyze_package_dependencies": {
              "doc": "Analyze package.json dependencies for cross-workspace references.",
              "signature": "(self, workspace: WorkspaceConfig) -> List[ImportInfo]"
            },
            "_build_dependency_graph": {
              "doc": "Build the cross-workspace dependency graph.",
              "signature": "(self, imports: List[ImportInfo]) -> Dict[str, Dict]"
            },
            "_detect_circular_dependencies": {
              "doc": "Detect circular dependencies using DFS algorithm with enhanced analysis.",
              "calls": [
                "_collect_cycle_imports",
                "_determine_cycle_severity_enhanced",
                "dfs"
              ],
              "signature": "(self, dependency_graph: Dict[str, Dict]) -> List[CircularDependency]"
            },
            "dfs": {
              "calls": [
                "_collect_cycle_imports",
                "_determine_cycle_severity_enhanced",
                "dfs"
              ],
              "signature": "(node: str, path: List[str]) -> None"
            },
            "_collect_cycle_imports": "(self, cycle: List[str]) -> List[ImportInfo]",
            "_determine_cycle_severity_enhanced": {
              "calls": [
                "_get_workspace_dependents_cached"
              ],
              "signature": "(self, cycle: List[str], cycle_imports: List[ImportInfo]) -> str"
            },
            "_extract_shared_types": {
              "doc": "Extract shared types and interfaces from imports.",
              "signature": "(self, imports: List[ImportInfo]) -> Dict[str, List[str]]"
            },
            "_get_cached_workspace_imports": "(self, workspace: WorkspaceConfig) -> Optional[List[ImportInfo]]",
            "_get_workspace_dependencies_cached": "(self, workspace_name: str) -> List[str]",
            "_get_workspace_dependents_cached": "(self, workspace_name: str) -> List[str]",
            "_build_bidirectional_relationships": {
              "doc": "Build bidirectional relationship mapping for refactoring impact analysis.",
              "signature": "(self, dependency_graph: Dict[str, Dict]) -> Dict[str, Dict]"
            },
            "_compress_data_safe": "(self, data: Dict, compression_type: str = \"workspace\") -> Dict",
            "_extract_python_types_from_import": {
              "doc": "Extract type names from Python imports.",
              "signature": "(self, import_name: str, content: str) -> List[str]"
            },
            "_filter_type_names": {
              "doc": "Filter a list of names to likely type/interface names.",
              "signature": "(self, names: List[str]) -> List[str]"
            },
            "_circular_dep_to_dict": {
              "doc": "Convert CircularDependency to dictionary for serialization with enhanced metadata.",
              "signature": "(self, circular_dep: CircularDependency) -> Dict"
            },
            "_prepare_root_index_data": {
              "calls": [
                "_circular_dep_to_dict",
                "_compress_data_safe"
              ],
              "signature": "(self, dependency_graph: Dict, circular_deps: List[CircularDependency], shared_types: Dict, bidirectional_deps: Dict, all_imports: List[ImportInfo]) -> Dict"
            },
            "_prepare_comprehensive_data": {
              "calls": [
                "_circular_dep_to_dict",
                "_compress_data_safe"
              ],
              "signature": "(self, dependency_graph: Dict, circular_deps: List[CircularDependency], shared_types: Dict, bidirectional_deps: Dict, workspace_imports: Dict, all_imports: List[ImportInfo]) -> Dict"
            }
          },
          "properties": [
            "for_root_index",
            "data",
            "compression_type"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:41:21.157297"
    },
    "scripts/project_index.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "generate_tree_structure": {
          "doc": "Generate a compact ASCII tree representation of the directory structure.",
          "calls": [
            "add_tree_level",
            "should_include_dir"
          ],
          "signature": "(root_path: Path, max_depth: int = MAX_TREE_DEPTH) -> List[str]"
        },
        "_generate_monorepo_tree": {
          "doc": "Generate a high-level tree view for monorepos showing workspaces.",
          "signature": "(root_path: Path, registry) -> List[str]"
        },
        "build_index": {
          "doc": "Build the enhanced index with architectural awareness.",
          "calls": [
            "_generate_monorepo_tree",
            "generate_tree_structure"
          ],
          "signature": "(root_dir: str) -> Tuple[Dict, int]"
        },
        "compress_index_if_needed": {
          "doc": "Compress index if it exceeds size limit.",
          "signature": "(index: Dict) -> Dict"
        },
        "print_summary": {
          "doc": "Print a helpful summary of what was indexed.",
          "calls": [
            "print_monorepo_summary"
          ],
          "signature": "(index: Dict, skipped_count: int)"
        },
        "print_monorepo_summary": {
          "doc": "Print a summary for monorepo indexing.",
          "signature": "(index: Dict)"
        },
        "build_index_with_workflow": {
          "calls": [
            "generate_tree_structure"
          ],
          "signature": "(root_dir: str = '.', target_workspaces: Optional[List[str]] = None, workflow_name: str = \"project_indexing\", max_workers: Optional[int] = None, show_progress: bool = True) -> Tuple[Dict, int]"
        },
        "main": {
          "doc": "Run the enhanced indexer with hierarchical and workflow support.",
          "calls": [
            "build_index",
            "build_index_with_workflow",
            "compress_index_if_needed",
            "print_summary"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "updated_by_hook": true,
      "updated_at": "2025-08-19T09:58:22.743244"
    },
    "scripts/lazy_index_loader.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "os",
        "threading",
        "time",
        "collections",
        "datetime",
        "pathlib",
        "typing",
        "weakref",
        "hashlib",
        "sys",
        "pathlib",
        "hierarchical_indexer",
        "workspace_config",
        "argparse"
      ],
      "functions": {
        "get_global_loader": {
          "doc": "Get or create the global loader instance.",
          "signature": "(root_path: Union[str, Path]) -> LazyIndexLoader",
          "called_by": [
            "load_root_index",
            "load_workspace_index"
          ]
        },
        "load_root_index": {
          "doc": "Load root index using global loader.",
          "calls": [
            "get_global_loader",
            "load_root_index"
          ],
          "signature": "(root_path: Union[str, Path] = \".\") -> Dict",
          "called_by": [
            "load_root_index",
            "LazyIndexLoader.get_workspace_dependencies",
            "LazyIndexLoader.get_workspace_dependents",
            "LazyIndexLoader._get_workspace_mapping"
          ]
        },
        "load_workspace_index": {
          "doc": "Load workspace index using global loader.",
          "calls": [
            "get_global_loader",
            "load_workspace_index"
          ],
          "signature": "(workspace_name: str, root_path: Union[str, Path] = \".\") -> Optional[Dict]",
          "called_by": [
            "load_workspace_index"
          ]
        }
      },
      "classes": {
        "CacheEntry": {
          "methods": {
            "__init__": "(self, data: Any, timestamp: float, size_bytes: int, access_count: int = 0)",
            "access": {
              "doc": "Mark this entry as accessed.",
              "signature": "(self)",
              "called_by": [
                "LRUCache.get"
              ]
            },
            "is_stale": {
              "doc": "Check if this cache entry is stale.",
              "signature": "(self, max_age_seconds: int = 3600) -> bool",
              "called_by": [
                "LRUCache.get"
              ]
            }
          },
          "doc": "Represents a single cache entry with metadata."
        },
        "LRUCache": {
          "methods": {
            "__init__": "(self, max_size_mb: int = 50, max_entries: int = 1000)",
            "get": {
              "doc": "Get item from cache if it exists and is not stale.",
              "calls": [
                "_remove_entry",
                "access",
                "is_stale"
              ],
              "signature": "(self, key: str, max_age_seconds: int = 3600) -> Optional[Any]",
              "called_by": [
                "LazyIndexLoader.load_workspace_index",
                "LazyIndexLoader.get_workspace_dependents",
                "LazyIndexLoader.load_root_index",
                "LazyIndexLoader._is_file_stale",
                "LazyIndexLoader.get_workspace_dependencies",
                "LazyIndexLoader._get_workspace_mapping"
              ]
            },
            "put": {
              "doc": "Put item into cache, evicting old entries if necessary.",
              "calls": [
                "_estimate_size",
                "_remove_entry"
              ],
              "signature": "(self, key: str, data: Any, size_bytes: Optional[int] = None) -> None",
              "called_by": [
                "LazyIndexLoader.load_workspace_index",
                "LazyIndexLoader.get_workspace_dependents",
                "LazyIndexLoader.load_root_index",
                "LazyIndexLoader.get_workspace_dependencies",
                "LazyIndexLoader._get_workspace_mapping"
              ]
            },
            "invalidate": {
              "doc": "Remove specific key from cache.",
              "calls": [
                "_remove_entry"
              ],
              "signature": "(self, key: str) -> bool",
              "called_by": [
                "LazyIndexLoader.invalidate_workspace"
              ]
            },
            "invalidate_pattern": {
              "doc": "Remove all keys matching pattern. Returns count of removed items.",
              "calls": [
                "_remove_entry"
              ],
              "signature": "(self, pattern: str) -> int"
            },
            "clear": {
              "doc": "Clear all cache entries.",
              "calls": [
                "clear"
              ],
              "signature": "(self) -> None",
              "called_by": [
                "LRUCache.clear",
                "LazyIndexLoader.invalidate_root_index"
              ]
            },
            "get_stats": {
              "doc": "Get cache statistics.",
              "signature": "(self) -> Dict[str, Any]",
              "called_by": [
                "LazyIndexLoader.get_cache_stats"
              ]
            },
            "_remove_entry": {
              "doc": "Remove entry and update size tracking.",
              "signature": "(self, key: str) -> None",
              "called_by": [
                "LRUCache.invalidate",
                "LRUCache.get",
                "LRUCache.invalidate_pattern",
                "LRUCache.put"
              ]
            },
            "_estimate_size": {
              "doc": "Estimate the memory size of data.",
              "signature": "(self, data: Any) -> int",
              "called_by": [
                "LRUCache.put"
              ]
            }
          },
          "doc": "Thread-safe LRU cache with size limits and staleness checking."
        },
        "LazyIndexLoader": {
          "methods": {
            "__init__": "(self, root_path: Union[str, Path], cache_size_mb: int = 100)",
            "load_root_index": {
              "calls": [
                "_is_file_stale",
                "_update_file_mtime",
                "get",
                "put"
              ],
              "signature": "(self, max_age_seconds: int = 3600, force_refresh: bool = False) -> Dict",
              "called_by": [
                "LazyIndexLoader.get_workspace_dependents",
                "LazyIndexLoader.get_workspace_dependencies",
                "load_root_index",
                "LazyIndexLoader._get_workspace_mapping"
              ]
            },
            "load_workspace_index": {
              "calls": [
                "_get_workspace_mapping",
                "_is_file_stale",
                "_update_file_mtime",
                "get",
                "put"
              ],
              "signature": "(self, workspace_name: str, max_age_seconds: int = 3600, force_refresh: bool = False) -> Optional[Dict]",
              "called_by": [
                "load_workspace_index"
              ]
            },
            "get_workspace_dependencies": {
              "calls": [
                "get",
                "load_root_index",
                "put"
              ],
              "signature": "(self, workspace_name: str) -> List[str]",
              "called_by": [
                "WorkspaceIndexer.index_workspace"
              ]
            },
            "get_workspace_dependents": {
              "calls": [
                "get",
                "load_root_index",
                "put"
              ],
              "signature": "(self, workspace_name: str) -> List[str]",
              "called_by": [
                "LazyIndexLoader.invalidate_workspace"
              ]
            },
            "invalidate_workspace": {
              "calls": [
                "get_workspace_dependents",
                "invalidate",
                "invalidate_workspace"
              ],
              "signature": "(self, workspace_name: str, cascade: bool = True) -> None",
              "called_by": [
                "LazyIndexLoader.invalidate_workspace"
              ]
            },
            "invalidate_root_index": {
              "doc": "Invalidate the root index cache.",
              "calls": [
                "clear"
              ],
              "signature": "(self) -> None"
            },
            "get_cache_stats": {
              "doc": "Get comprehensive cache statistics.",
              "calls": [
                "get_stats"
              ],
              "signature": "(self) -> Dict[str, Any]"
            },
            "_get_workspace_mapping": {
              "doc": "Get workspace mapping with caching.",
              "calls": [
                "get",
                "load_root_index",
                "put"
              ],
              "signature": "(self, workspace_name: str) -> Optional[Dict]",
              "called_by": [
                "LazyIndexLoader.load_workspace_index"
              ]
            },
            "_is_file_stale": {
              "doc": "Check if a file has been modified since last cache.",
              "calls": [
                "get"
              ],
              "signature": "(self, file_path: Path) -> bool",
              "called_by": [
                "LazyIndexLoader.load_workspace_index",
                "LazyIndexLoader.load_root_index"
              ]
            },
            "_update_file_mtime": {
              "doc": "Update the cached modification time for a file.",
              "signature": "(self, file_path: Path) -> None",
              "called_by": [
                "LazyIndexLoader.load_workspace_index",
                "LazyIndexLoader.load_root_index"
              ]
            }
          },
          "properties": [
            "max_age_seconds",
            "force_refresh",
            "workspace_name",
            "max_age_seconds",
            "force_refresh",
            "workspace_name",
            "workspace_name",
            "workspace_name",
            "cascade"
          ]
        }
      },
      "call_graph": {}
    },
    "scripts/index_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "re",
        "fnmatch",
        "pathlib",
        "typing"
      ],
      "functions": {
        "extract_function_calls_python": {
          "doc": "Extract function calls from Python code body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_python_signatures"
          ]
        },
        "extract_function_calls_javascript": {
          "doc": "Extract function calls from JavaScript/TypeScript code body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_javascript_signatures"
          ]
        },
        "build_call_graph": {
          "doc": "Build bidirectional call graph from extracted functions and methods.",
          "signature": "(functions: Dict, classes: Dict) -> Tuple[Dict, Dict]"
        },
        "extract_python_signatures": {
          "doc": "Extract Python function and class signatures with full details for all files.",
          "calls": [
            "extract_function_calls_python"
          ],
          "signature": "(content: str) -> Dict[str, Dict]"
        },
        "extract_javascript_signatures": {
          "doc": "Extract JavaScript/TypeScript function and class signatures with full details.",
          "calls": [
            "extract_function_calls_javascript"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_function_calls_shell": {
          "doc": "Extract function calls from shell script body.",
          "signature": "(body: str, all_functions: Set[str]) -> List[str]",
          "called_by": [
            "extract_shell_signatures"
          ]
        },
        "extract_shell_signatures": {
          "doc": "Extract shell script function signatures and structure.",
          "calls": [
            "extract_function_calls_shell"
          ],
          "signature": "(content: str) -> Dict[str, any]"
        },
        "extract_markdown_structure": {
          "doc": "Extract headers and architectural hints from markdown files.",
          "signature": "(file_path: Path) -> Dict[str, List[str]]"
        },
        "infer_file_purpose": {
          "doc": "Infer the purpose of a file from its name and location.",
          "signature": "(file_path: Path) -> Optional[str]"
        },
        "infer_directory_purpose": {
          "doc": "Infer directory purpose from naming patterns and contents.",
          "signature": "(path: Path, files_within: List[str]) -> Optional[str]"
        },
        "get_language_name": {
          "doc": "Get readable language name from extension.",
          "signature": "(extension: str) -> str"
        },
        "parse_gitignore": {
          "doc": "Parse a .gitignore file and return list of patterns.",
          "signature": "(gitignore_path: Path) -> List[str]",
          "called_by": [
            "load_gitignore_patterns"
          ]
        },
        "load_gitignore_patterns": {
          "doc": "Load all gitignore patterns from project root and merge with defaults.",
          "calls": [
            "parse_gitignore"
          ],
          "signature": "(root_path: Path) -> Set[str]",
          "called_by": [
            "should_index_file"
          ]
        },
        "matches_gitignore_pattern": {
          "doc": "Check if a path matches any gitignore pattern.",
          "signature": "(path: Path, patterns: Set[str], root_path: Path) -> bool",
          "called_by": [
            "should_index_file"
          ]
        },
        "should_index_file": {
          "doc": "Check if we should index this file.",
          "calls": [
            "load_gitignore_patterns",
            "matches_gitignore_pattern"
          ],
          "signature": "(path: Path, root_path: Path = None) -> bool"
        }
      },
      "classes": {},
      "constants": {
        "IGNORE_DIRS": "collection",
        "PARSEABLE_LANGUAGES": "collection",
        "CODE_EXTENSIONS": "collection",
        "MARKDOWN_EXTENSIONS": "collection",
        "DIRECTORY_PURPOSES": "collection"
      },
      "call_graph": {}
    },
    "scripts/update_index_enhanced.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "os",
        "pathlib",
        "datetime",
        "typing",
        "time",
        "index_utils",
        "workspace_config",
        "workspace_indexer"
      ],
      "functions": {
        "find_project_modules": {
          "doc": "Find project modules (index_utils, workspace_config, etc.) in project or system location.",
          "signature": "()"
        },
        "get_workspace_config_cached": {
          "doc": "Get workspace configuration with caching.",
          "signature": "(project_root: Path) -> Optional[Dict]",
          "called_by": [
            "check_workspace_staleness",
            "check_workspace_configuration_changes",
            "run_workspace_reindex",
            "run_reindex",
            "update_root_index_after_workspace_reindex",
            "main",
            "get_workspace_for_file",
            "get_workspace_index_path",
            "get_dependent_workspaces",
            "update_root_index_workspace_registry",
            "handle_file_update",
            "check_workspace_staleness",
            "check_workspace_configuration_changes",
            "run_workspace_reindex",
            "run_reindex",
            "update_root_index_after_workspace_reindex",
            "main",
            "get_workspace_for_file",
            "get_workspace_index_path",
            "get_dependent_workspaces",
            "handle_cross_workspace_dependencies",
            "update_root_index_workspace_registry",
            "detect_file_move",
            "handle_file_update"
          ]
        },
        "get_workspace_for_file": {
          "doc": "Determine which workspace a file belongs to.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(file_path: Path, project_root: Path) -> Optional[str]",
          "called_by": [
            "handle_file_update",
            "detect_file_move",
            "handle_file_update"
          ]
        },
        "get_workspace_index_path": {
          "doc": "Get the path to a workspace's index file.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> Optional[Path]",
          "called_by": [
            "update_workspace_index",
            "handle_cross_workspace_dependencies",
            "update_root_index_workspace_registry",
            "update_workspace_index",
            "handle_basic_cross_workspace_dependencies",
            "update_workspace_dependencies",
            "update_root_index_workspace_registry",
            "detect_file_move",
            "handle_cross_workspace_file_move"
          ]
        },
        "get_dependent_workspaces": {
          "doc": "Get list of workspaces that depend on the given workspace.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> List[str]",
          "called_by": [
            "handle_cross_workspace_dependencies",
            "handle_basic_cross_workspace_dependencies"
          ]
        },
        "update_workspace_index": {
          "doc": "Update a specific workspace index.",
          "calls": [
            "get_workspace_index_path",
            "update_file_in_index"
          ],
          "signature": "(workspace_name: str, file_path: Path, project_root: Path) -> bool",
          "called_by": [
            "handle_file_update",
            "handle_file_update"
          ]
        },
        "handle_cross_workspace_dependencies": {
          "doc": "Handle cascade updates for dependent workspaces.",
          "calls": [
            "get_dependent_workspaces",
            "get_workspace_index_path"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> None",
          "called_by": [
            "handle_file_update",
            "handle_cross_workspace_file_move",
            "handle_file_update"
          ]
        },
        "update_root_index_workspace_registry": {
          "doc": "Update the root index workspace registry when workspace relationships change.",
          "calls": [
            "get_workspace_config_cached",
            "get_workspace_index_path"
          ],
          "signature": "(project_root: Path) -> None",
          "called_by": [
            "handle_file_update",
            "handle_cross_workspace_file_move",
            "handle_file_update"
          ]
        },
        "update_file_in_index": {
          "doc": "Update a single file's entry in the enhanced index.",
          "signature": "(index_path: str, file_path: str, project_root: str) -> bool",
          "called_by": [
            "update_workspace_index",
            "handle_file_update",
            "update_workspace_index",
            "handle_file_update"
          ]
        },
        "handle_file_update": {
          "doc": "Handle a file update with workspace awareness.",
          "calls": [
            "get_workspace_config_cached",
            "get_workspace_for_file",
            "handle_cross_workspace_dependencies",
            "update_file_in_index",
            "update_root_index_workspace_registry",
            "update_workspace_index"
          ],
          "signature": "(file_path: Path, project_root: Path) -> None",
          "called_by": [
            "main",
            "main"
          ]
        },
        "main": {
          "doc": "Process PostToolUse hook input and update index with workspace awareness.",
          "calls": [
            "handle_file_update"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "constants": {
        "CACHE_TTL": "number"
      },
      "call_graph": {}
    },
    "scripts/reindex_if_needed.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "find_project_modules": {
          "doc": "Find project modules in project or system location.",
          "signature": "()"
        },
        "get_workflow_orchestrator": {
          "doc": "Get or create workflow orchestrator for the project.",
          "signature": "(project_root: Path) -> Optional['TaskWorkflowOrchestrator']"
        },
        "enable_workflow_integration": {
          "doc": "Enable workflow integration for the current reindexing session.",
          "calls": [
            "get_workflow_orchestrator"
          ],
          "signature": "(project_root: Path, context: Optional[Dict] = None) -> bool"
        },
        "trigger_workflow_hook": {
          "doc": "Trigger a workflow integration hook if workflow is enabled.",
          "calls": [
            "trigger_workflow_hook"
          ],
          "signature": "(hook_name: str, **kwargs)"
        },
        "get_workspace_config_cached": {
          "doc": "Get workspace configuration with caching.",
          "signature": "(project_root: Path) -> Optional[Dict]"
        },
        "check_index_features": {
          "doc": "Check if index has all required features.",
          "signature": "(index_path: Path) -> Tuple[bool, Optional[str]]"
        },
        "check_index_staleness": {
          "doc": "Check if index is older than threshold.",
          "signature": "(index_path: Path, threshold_hours: int = 24) -> bool"
        },
        "check_workspace_staleness": {
          "doc": "Check if a specific workspace is stale.",
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> Tuple[bool, Optional[str]]"
        },
        "check_missing_documentation": {
          "doc": "Check if important documentation files are missing from index.",
          "signature": "(index_path: Path, workspace_root: Path) -> bool"
        },
        "check_structural_changes": {
          "doc": "Check if directory structure has significantly changed.",
          "signature": "(index_path: Path, workspace_root: Path) -> bool"
        },
        "count_hook_updates": {
          "doc": "Count how many files were updated by hooks vs full index.",
          "signature": "(index_path: Path) -> Tuple[int, int]"
        },
        "check_workspace_configuration_changes": {
          "doc": "Check if workspace configuration has changed.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(project_root: Path) -> Tuple[bool, List[str]]"
        },
        "run_workspace_reindex": {
          "doc": "Run reindex for a specific workspace.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> bool"
        },
        "run_reindex": {
          "doc": "Run reindexing with workspace awareness.",
          "calls": [
            "get_workspace_config_cached",
            "run_reindex",
            "run_single_repo_reindex",
            "run_workspace_reindex",
            "update_root_index_after_workspace_reindex"
          ],
          "signature": "(project_root: Path, selective_workspaces: Optional[List[str]] = None) -> bool"
        },
        "run_single_repo_reindex": {
          "doc": "Run traditional single-repo reindex.",
          "signature": "(project_root: Path) -> bool"
        },
        "update_root_index_after_workspace_reindex": {
          "doc": "Update root index after workspace reindexing.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(project_root: Path, reindexed_workspaces: List[str]) -> None"
        },
        "main": {
          "decorators": [
            "performance_timing"
          ],
          "doc": "Main hook entry point with workspace awareness and workflow integration.",
          "calls": [
            "enable_workflow_integration",
            "get_workspace_config_cached",
            "handle_single_repo_reindex",
            "handle_workspace_aware_reindex",
            "trigger_workflow_hook"
          ],
          "signature": "()"
        },
        "handle_single_repo_reindex": {
          "doc": "Handle single-repo reindexing logic.",
          "calls": [
            "check_index_features",
            "check_index_staleness",
            "check_missing_documentation",
            "check_structural_changes",
            "count_hook_updates",
            "run_single_repo_reindex"
          ],
          "signature": "(root_index_path: Path, project_root: Path) -> None"
        },
        "handle_workspace_aware_reindex": {
          "doc": "Handle workspace-aware reindexing logic.",
          "calls": [
            "check_workspace_configuration_changes",
            "check_workspace_staleness",
            "run_reindex"
          ],
          "signature": "(project_root: Path, workspace_config: Dict) -> None"
        }
      },
      "classes": {},
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:01:42.744695"
    },
    "scripts/detect_external_changes.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "os",
        "json",
        "subprocess",
        "pathlib",
        "datetime",
        "sys"
      ],
      "functions": {
        "get_file_mtime": {
          "doc": "Get file modification time as timestamp.",
          "signature": "(file_path)",
          "called_by": [
            "detect_external_changes"
          ]
        },
        "detect_external_changes": {
          "calls": [
            "get_file_mtime"
          ],
          "signature": "(index_path, project_root)"
        },
        "check_git_changes": "(project_root)"
      },
      "classes": {},
      "call_graph": {}
    },
    "scripts/smart_compressor.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "time",
        "gc",
        "typing",
        "collections",
        "threading",
        "weakref",
        "argparse"
      ],
      "functions": {
        "compress_index_safe": {
          "calls": [
            "compress_root_index",
            "compress_workspace_index"
          ],
          "signature": "(index: Dict, index_type: str = \"workspace\") -> Dict"
        }
      },
      "classes": {
        "CircularReferenceDetector": {
          "methods": {
            "__init__": "(self)",
            "detect_cycles": {
              "calls": [
                "detect_cycles"
              ],
              "signature": "(self, obj: Any, path: str = \"root\") -> Tuple[bool, List[str]]",
              "called_by": [
                "SmartCompressor.compress_root_index",
                "SmartCompressor.compress_workspace_index",
                "CircularReferenceDetector.detect_cycles"
              ]
            },
            "create_reference_marker": {
              "doc": "Create a reference marker for an object to break cycles.",
              "signature": "(self, obj: Any) -> str"
            }
          },
          "doc": "Detects and handles circular references in data structures.",
          "properties": [
            "obj",
            "path"
          ]
        },
        "BatchProcessor": {
          "methods": {
            "__init__": "(self, batch_size: int = 100, progress_callback=None)",
            "process_items": {
              "signature": "(self, items: List[Any], processor_func, description: str = \"Processing\")",
              "called_by": [
                "BatchProcessor.process_dict_items"
              ]
            },
            "process_dict_items": {
              "doc": "Process dictionary items in batches.",
              "calls": [
                "dict_processor",
                "process_items"
              ],
              "signature": "(self, data: Dict, processor_func, description: str = \"Processing\")",
              "called_by": [
                "SmartCompressor._compress_workspace_index_data"
              ]
            },
            "dict_processor": {
              "signature": "(item)",
              "called_by": [
                "BatchProcessor.process_dict_items"
              ]
            }
          },
          "doc": "Handles batch processing of large datasets with progress tracking.",
          "properties": [
            "items",
            "processor_func",
            "description"
          ]
        },
        "SmartCompressor": {
          "methods": {
            "__init__": "(self, enable_progress: bool = True)",
            "compress_root_index": {
              "calls": [
                "_aggressive_root_compression",
                "_calculate_compression_ratio",
                "_compress_root_index_data",
                "detect_cycles"
              ],
              "signature": "(self, index: Dict) -> Dict",
              "called_by": [
                "compress_index_safe"
              ]
            },
            "compress_workspace_index": {
              "calls": [
                "_calculate_compression_ratio",
                "_compress_workspace_index_data",
                "detect_cycles"
              ],
              "signature": "(self, index: Dict) -> Dict",
              "called_by": [
                "compress_index_safe"
              ]
            },
            "_compress_root_index_data": {
              "doc": "Apply lightweight compression to root index data.",
              "calls": [
                "_compress_dependencies",
                "_compress_workspace_registry"
              ],
              "signature": "(self, index: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor.compress_root_index"
              ]
            },
            "_compress_workspace_registry": {
              "doc": "Compress workspace registry with cycle detection.",
              "signature": "(self, registry: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor._compress_root_index_data"
              ]
            },
            "_compress_dependencies": {
              "doc": "Compress cross-workspace dependencies with cycle breaking.",
              "signature": "(self, dependencies: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor._compress_root_index_data"
              ]
            },
            "_compress_workspace_index_data": {
              "doc": "Apply standard compression to workspace index data.",
              "calls": [
                "_compress_dependency_graph",
                "_compress_file_entries",
                "compress_field",
                "process_dict_items"
              ],
              "signature": "(self, index: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor.compress_workspace_index"
              ]
            },
            "compress_field": {
              "calls": [
                "_compress_dependency_graph",
                "_compress_file_entries"
              ],
              "signature": "(key, value)",
              "called_by": [
                "SmartCompressor._compress_workspace_index_data"
              ]
            },
            "_compress_file_entries": {
              "doc": "Compress file entries removing redundant information.",
              "signature": "(self, files: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor.compress_field",
                "SmartCompressor._compress_workspace_index_data"
              ]
            },
            "_compress_dependency_graph": {
              "doc": "Compress dependency graph with cycle detection.",
              "signature": "(self, dep_graph: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor.compress_field",
                "SmartCompressor._compress_workspace_index_data"
              ]
            },
            "_aggressive_root_compression": {
              "doc": "Apply more aggressive compression if size limit exceeded.",
              "signature": "(self, index: Dict, detector: CircularReferenceDetector) -> Dict",
              "called_by": [
                "SmartCompressor.compress_root_index"
              ]
            },
            "_calculate_compression_ratio": {
              "doc": "Calculate and update compression ratio statistics.",
              "signature": "(self, original: Dict, compressed: Dict)",
              "called_by": [
                "SmartCompressor.compress_root_index",
                "SmartCompressor.compress_workspace_index"
              ]
            },
            "_progress_callback": {
              "doc": "Default progress callback.",
              "signature": "(self, processed: int, total: int, percent: float, description: str)"
            },
            "get_compression_stats": {
              "doc": "Get compression statistics.",
              "signature": "(self) -> Dict"
            },
            "reset_stats": {
              "doc": "Reset compression statistics.",
              "signature": "(self)"
            }
          },
          "properties": [
            "index",
            "index"
          ]
        }
      },
      "call_graph": {}
    },
    "scripts/monorepo_detector.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "detect_monorepo": {
          "calls": [
            "detect",
            "to_dict"
          ],
          "signature": "(root_path: Union[str, Path]) -> Dict"
        }
      },
      "classes": {
        "DetectionResult": {
          "methods": {
            "__init__": "(self, monorepo: bool = False, tool: Optional[str] = None, workspace_registry: Optional[Dict[str, str]] = None, config_path: Optional[str] = None, detection_method: str = \"none\", errors: Optional[List[str]] = None)",
            "to_dict": {
              "doc": "Convert to dictionary for JSON serialization.",
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Standardized detection result structure."
        },
        "BaseDetector": {
          "methods": {
            "__init__": "(self, root_path: Path)",
            "detect": {
              "doc": "Detect workspaces. Override in subclasses.",
              "signature": "(self) -> Optional[DetectionResult]"
            },
            "_safe_read_json": {
              "doc": "Safely read and parse JSON file.",
              "signature": "(self, file_path: Path) -> Optional[Dict]"
            },
            "_safe_read_yaml": {
              "doc": "Safely read and parse YAML file.",
              "signature": "(self, file_path: Path) -> Optional[Dict]"
            },
            "_resolve_workspace_paths": {
              "doc": "Resolve workspace patterns to actual directories.",
              "signature": "(self, patterns: List[str]) -> Dict[str, str]"
            }
          },
          "doc": "Base class for tool-specific detectors."
        },
        "NxDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_resolve_workspace_paths",
                "_safe_read_json"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect Nx monorepo configuration."
        },
        "LernaDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_resolve_workspace_paths",
                "_safe_read_json"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect Lerna monorepo configuration."
        },
        "YarnWorkspacesDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_resolve_workspace_paths",
                "_safe_read_json"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect Yarn Workspaces configuration."
        },
        "PnpmWorkspacesDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_resolve_workspace_paths",
                "_safe_read_yaml"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect PNPM Workspaces configuration."
        },
        "RushDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_safe_read_json"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect Rush monorepo configuration."
        },
        "ManualConfigDetector": {
          "methods": {
            "detect": {
              "calls": [
                "_resolve_workspace_paths",
                "_safe_read_json"
              ],
              "signature": "(self) -> Optional[DetectionResult]"
            }
          },
          "inherits": [
            "BaseDetector"
          ],
          "doc": "Detect manual configuration override."
        },
        "MonorepoDetector": {
          "methods": {
            "__init__": "(self, root_path: Union[str, Path])",
            "detect": {
              "doc": "Run detection with all available detectors.",
              "calls": [
                "_heuristic_detection",
                "detect"
              ],
              "signature": "(self) -> DetectionResult"
            },
            "_heuristic_detection": {
              "doc": "Fallback heuristic analysis for edge cases.",
              "signature": "(self) -> DetectionResult"
            }
          },
          "doc": "Main monorepo detection orchestrator."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T11:08:29.276157"
    },
    "scripts/parallel_workspace_processor.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "process_workspaces_parallel": {
          "calls": [
            "process_workspaces_parallel"
          ],
          "signature": "(root_path: Union[str, Path], workspace_names: Optional[List[str]] = None, max_workers: Optional[int] = None, show_progress: bool = True) -> Dict[str, Dict]"
        },
        "process_workspaces_with_analysis": {
          "calls": [
            "process_workspaces_with_analysis"
          ],
          "signature": "(root_path: Union[str, Path], workspace_names: Optional[List[str]] = None, max_workers: Optional[int] = None, show_progress: bool = True) -> Dict[str, Any]"
        }
      },
      "classes": {
        "ProcessingProgress": {
          "methods": {
            "percentage_complete": {
              "decorators": [
                "property"
              ],
              "doc": "Calculate completion percentage.",
              "signature": "(self) -> float"
            },
            "elapsed_time": {
              "decorators": [
                "property"
              ],
              "doc": "Calculate elapsed time in seconds.",
              "signature": "(self) -> float"
            },
            "estimated_remaining": {
              "decorators": [
                "property"
              ],
              "doc": "Estimate remaining time in seconds.",
              "signature": "(self) -> float"
            }
          },
          "decorators": [
            "dataclass"
          ],
          "doc": "Track progress of workspace processing operations.",
          "properties": [
            "total_workspaces",
            "completed",
            "failed",
            "in_progress",
            "completed_workspaces",
            "failed_workspaces",
            "start_time"
          ]
        },
        "WorkspaceTask": {
          "methods": {},
          "decorators": [
            "dataclass"
          ],
          "doc": "Represents a workspace processing task.",
          "properties": [
            "workspace_name",
            "priority",
            "dependencies",
            "estimated_duration",
            "task_id"
          ]
        },
        "SharedResourceManager": {
          "methods": {
            "__init__": "(self)",
            "get_file_lock": {
              "doc": "Get a thread-safe lock for a specific file.",
              "signature": "(self, file_path: str) -> threading.Lock"
            },
            "cache_workspace_result": {
              "doc": "Thread-safe caching of workspace results.",
              "signature": "(self, workspace_name: str, result: Dict)"
            },
            "get_cached_workspace_result": {
              "doc": "Get cached workspace result if available.",
              "signature": "(self, workspace_name: str) -> Optional[Dict]"
            },
            "update_cross_workspace_results": {
              "doc": "Thread-safe update of cross-workspace analysis results.",
              "signature": "(self, results: Dict)"
            },
            "get_cross_workspace_results": {
              "doc": "Get current cross-workspace analysis results.",
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Thread-safe manager for shared resources and caches."
        },
        "ParallelWorkspaceProcessor": {
          "methods": {
            "__init__": "(self, registry: WorkspaceRegistry, max_workers: Optional[int] = None, memory_limit_mb: int = 100, enable_throttling: bool = True, workflow_integration: bool = False)",
            "add_progress_callback": {
              "doc": "Add a callback function to receive progress updates.",
              "signature": "(self, callback: Callable[[ProcessingProgress], None])"
            },
            "register_workflow_hook": "(self, hook_name: str, callback: Callable)",
            "trigger_workflow_hook": "(self, hook_name: str, **kwargs)",
            "set_task_context": "(self, context: Dict[str, Any])",
            "get_task_context": {
              "doc": "Get current task context.",
              "signature": "(self) -> Dict[str, Any]"
            },
            "_notify_progress": {
              "doc": "Notify all progress callbacks of updates.",
              "signature": "(self, progress: ProcessingProgress)"
            },
            "_check_memory_usage": {
              "doc": "Check if memory usage is within limits.",
              "signature": "(self) -> bool"
            },
            "_wait_for_memory": {
              "doc": "Wait for memory usage to drop below limits.",
              "calls": [
                "_check_memory_usage"
              ],
              "signature": "(self, timeout: float = 5.0) -> bool"
            },
            "_create_workspace_indexer": {
              "doc": "Create a new WorkspaceIndexer for the current thread.",
              "signature": "(self) -> WorkspaceIndexer"
            },
            "_create_cross_workspace_analyzer": {
              "doc": "Create a new CrossWorkspaceAnalyzer for the current thread.",
              "signature": "(self) -> CrossWorkspaceAnalyzer"
            },
            "_index_single_workspace": {
              "decorators": [
                "performance_timing"
              ],
              "calls": [
                "_create_workspace_indexer",
                "_wait_for_memory",
                "cache_workspace_result",
                "get_cached_workspace_result",
                "get_task_context",
                "trigger_workflow_hook"
              ],
              "signature": "(self, workspace_name: str, progress: ProcessingProgress) -> Dict"
            },
            "_sort_workspaces_by_dependencies": "(self, workspace_names: List[str]) -> List[WorkspaceTask]",
            "process_workspaces_parallel": {
              "calls": [
                "_notify_progress",
                "_sort_workspaces_by_dependencies"
              ],
              "signature": "(self, workspace_names: Optional[List[str]] = None, show_progress: bool = True) -> Dict[str, Dict]"
            },
            "analyze_cross_workspace_dependencies": {
              "decorators": [
                "performance_timing"
              ],
              "calls": [
                "_create_cross_workspace_analyzer",
                "get_task_context",
                "trigger_workflow_hook",
                "update_cross_workspace_results"
              ],
              "signature": "(self, workspace_results: Dict[str, Dict]) -> Dict"
            },
            "process_workspaces_with_analysis": {
              "calls": [
                "analyze_cross_workspace_dependencies",
                "process_workspaces_parallel"
              ],
              "signature": "(self, workspace_names: Optional[List[str]] = None, include_cross_analysis: bool = True, show_progress: bool = True) -> Dict[str, Any]"
            },
            "shutdown": {
              "doc": "Request graceful shutdown of the processor.",
              "signature": "(self)"
            }
          },
          "properties": [
            "registry",
            "max_workers",
            "memory_limit_mb",
            "enable_throttling",
            "workflow_integration",
            "hook_name",
            "callback",
            "hook_name",
            "context",
            "workspace_name",
            "progress",
            "workspace_names",
            "workspace_names",
            "show_progress",
            "workspace_results",
            "workspace_names",
            "include_cross_analysis",
            "show_progress"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T09:54:48.461345"
    },
    "scripts/workspace_config.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "load_workspace_config": {
          "calls": [
            "load_configuration"
          ],
          "signature": "(root_path: Union[str, Path]) -> WorkspaceRegistry"
        }
      },
      "classes": {
        "WorkspaceConfig": {
          "methods": {
            "__init__": {
              "calls": [
                "_apply_performance_profile",
                "_detect_package_manager"
              ],
              "signature": "(self, name: str, path: str, root_path: Path, ignore_patterns: Optional[List[str]] = None, custom_settings: Optional[Dict] = None, performance_profile: str = \"balanced\", include: bool = True, indexing_depth: Optional[int] = None, max_files: Optional[int] = None)"
            },
            "_detect_package_manager": {
              "doc": "Detect the package manager used in this workspace.",
              "signature": "(self) -> str"
            },
            "_apply_performance_profile": {
              "doc": "Apply performance profile defaults if not explicitly set.",
              "signature": "(self)"
            },
            "get_performance_profile": {
              "doc": "Get the current performance profile settings.",
              "signature": "(self) -> Dict"
            },
            "should_skip_dependency_analysis": {
              "doc": "Check if dependency analysis should be skipped.",
              "signature": "(self) -> bool"
            },
            "should_skip_cross_workspace_analysis": {
              "doc": "Check if cross-workspace analysis should be skipped.",
              "signature": "(self) -> bool"
            },
            "get_max_files": {
              "doc": "Get the maximum number of files to index.",
              "signature": "(self) -> Optional[int]"
            },
            "get_indexing_depth": {
              "doc": "Get the maximum indexing depth.",
              "signature": "(self) -> Optional[int]"
            },
            "get_file_size_limit_mb": {
              "doc": "Get the file size limit in MB.",
              "signature": "(self) -> float"
            },
            "get_ignore_patterns": {
              "doc": "Get all ignore patterns for this workspace.",
              "signature": "(self) -> Set[str]"
            },
            "to_dict": {
              "doc": "Convert to dictionary for serialization.",
              "calls": [
                "get_ignore_patterns"
              ],
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Represents configuration for a single workspace."
        },
        "WorkspaceRegistry": {
          "methods": {
            "__init__": {
              "calls": [
                "_load_workspaces"
              ],
              "signature": "(self, root_path: Path, detection_result: DetectionResult)"
            },
            "_load_workspaces": {
              "doc": "Load workspace configurations from detection result.",
              "signature": "(self)"
            },
            "get_workspace": {
              "doc": "Get workspace configuration by name.",
              "signature": "(self, name: str) -> Optional[WorkspaceConfig]"
            },
            "get_workspace_by_path": {
              "doc": "Determine which workspace a file belongs to.",
              "signature": "(self, file_path: Union[str, Path]) -> Optional[WorkspaceConfig]"
            },
            "get_all_workspaces": {
              "doc": "Get all workspace configurations.",
              "signature": "(self) -> List[WorkspaceConfig]"
            },
            "get_workspace_names": {
              "doc": "Get all workspace names.",
              "signature": "(self) -> List[str]"
            },
            "set_dependencies": {
              "doc": "Set dependencies for a workspace.",
              "signature": "(self, workspace_name: str, dependencies: List[str])"
            },
            "get_dependencies": {
              "doc": "Get dependencies for a workspace.",
              "signature": "(self, workspace_name: str) -> List[str]"
            },
            "get_dependents": {
              "doc": "Get workspaces that depend on this one.",
              "signature": "(self, workspace_name: str) -> List[str]"
            },
            "validate": {
              "doc": "Validate the workspace configuration.",
              "calls": [
                "check_circular",
                "get_dependencies"
              ],
              "signature": "(self) -> List[str]"
            },
            "check_circular": {
              "calls": [
                "check_circular",
                "get_dependencies"
              ],
              "signature": "(workspace_name: str, visited: Set[str], path: List[str]) -> bool"
            },
            "to_dict": {
              "doc": "Convert to dictionary for serialization.",
              "calls": [
                "to_dict"
              ],
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Registry of all workspaces in the monorepo."
        },
        "WorkspaceConfigManager": {
          "methods": {
            "__init__": "(self, root_path: Union[str, Path])",
            "load_configuration": {
              "calls": [
                "_apply_manual_overrides"
              ],
              "signature": "(self, force_refresh: bool = False) -> WorkspaceRegistry"
            },
            "_apply_manual_overrides": {
              "doc": "Apply manual configuration overrides.",
              "calls": [
                "_apply_performance_profile",
                "get_workspace",
                "set_dependencies"
              ],
              "signature": "(self, registry: WorkspaceRegistry) -> WorkspaceRegistry"
            },
            "get_workspace_for_file": {
              "doc": "Get the workspace that contains the given file.",
              "calls": [
                "get_workspace_by_path",
                "load_configuration"
              ],
              "signature": "(self, file_path: Union[str, Path]) -> Optional[WorkspaceConfig]"
            },
            "validate_configuration": {
              "doc": "Validate the current workspace configuration.",
              "calls": [
                "load_configuration",
                "validate"
              ],
              "signature": "(self) -> List[str]"
            },
            "clear_cache": {
              "doc": "Clear the configuration cache.",
              "signature": "(self)"
            },
            "is_monorepo": {
              "doc": "Check if the current project is a monorepo.",
              "calls": [
                "load_configuration"
              ],
              "signature": "(self) -> bool"
            },
            "get_monorepo_info": {
              "doc": "Get comprehensive monorepo information.",
              "calls": [
                "get_workspace_names",
                "load_configuration"
              ],
              "signature": "(self) -> Dict"
            },
            "get_workspace_by_performance_profile": {
              "doc": "Get all workspaces using a specific performance profile.",
              "calls": [
                "get_all_workspaces",
                "load_configuration"
              ],
              "signature": "(self, profile: str) -> List[WorkspaceConfig]"
            },
            "validate_performance_profile": {
              "doc": "Validate that a performance profile is valid.",
              "signature": "(self, profile: str) -> bool"
            },
            "get_available_performance_profiles": {
              "doc": "Get all available performance profiles with their descriptions.",
              "signature": "(self) -> Dict[str, Dict]"
            },
            "create_interactive_config": {
              "doc": "Create an interactive configuration template.",
              "calls": [
                "get_all_workspaces",
                "get_file_size_limit_mb",
                "load_configuration"
              ],
              "signature": "(self) -> Dict"
            },
            "validate_config_file": {
              "doc": "Validate configuration file format and values.",
              "calls": [
                "get_workspace",
                "load_configuration",
                "validate_performance_profile"
              ],
              "signature": "(self, config_path: Optional[Path] = None) -> List[str]"
            },
            "get_global_settings": {
              "doc": "Get global configuration settings.",
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Main workspace configuration manager with caching and validation.",
          "properties": [
            "force_refresh"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:09:00.157829",
      "purpose": "Configuration"
    },
    "scripts/hierarchical_indexer.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "generate_hierarchical_index": {
          "calls": [
            "generate_root_index"
          ],
          "signature": "(root_path: Union[str, Path], force_monorepo: bool = False) -> Dict"
        }
      },
      "classes": {
        "HierarchicalIndexManager": {
          "methods": {
            "__init__": "(self, root_path: Union[str, Path])",
            "detect_project_type": "(self) -> Tuple[bool, str]",
            "generate_root_index": {
              "calls": [
                "_generate_monorepo_root_index",
                "_generate_single_repo_index",
                "detect_project_type"
              ],
              "signature": "(self, force_monorepo: bool = False) -> Dict"
            },
            "_generate_monorepo_root_index": {
              "doc": "Generate lightweight root index for monorepo.",
              "calls": [
                "_build_cross_workspace_dependencies_fallback",
                "_generate_workspace_overview_tree",
                "_validate_generation_constraints"
              ],
              "signature": "(self, detection_method: str) -> Dict"
            },
            "_generate_single_repo_index": {
              "doc": "Generate basic single-repo index structure.",
              "signature": "(self) -> Dict"
            },
            "_build_cross_workspace_dependencies_fallback": "(self, registry: WorkspaceRegistry) -> Dict[str, Dict]",
            "_generate_workspace_overview_tree": {
              "doc": "Generate high-level workspace tree for overview.",
              "signature": "(self, registry: WorkspaceRegistry) -> Dict"
            },
            "_validate_generation_constraints": {
              "doc": "Validate that the generated index meets performance constraints.",
              "signature": "(self, index: Dict)"
            },
            "save_root_index": {
              "doc": "Save the root index to disk.",
              "signature": "(self, index: Dict, output_path: Optional[Path] = None) -> Path"
            },
            "get_workspace_registry": {
              "doc": "Get the workspace registry for this project.",
              "signature": "(self) -> WorkspaceRegistry"
            }
          },
          "properties": [
            "force_monorepo",
            "Exception"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:38:52.831442"
    },
    "scripts/monorepo_commands.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "sys",
        "time",
        "argparse",
        "pathlib",
        "typing",
        "datetime",
        "workspace_config",
        "parallel_workspace_processor",
        "performance_monitor",
        "project_index"
      ],
      "functions": {
        "main": {
          "doc": "CLI entry point for monorepo commands.",
          "calls": [
            "dependencies",
            "index_monorepo",
            "index_workspace",
            "interactive_config",
            "migrate",
            "stats",
            "status"
          ],
          "signature": "()"
        }
      },
      "classes": {
        "MonorepoCommands": {
          "methods": {
            "__init__": "(self, root_path: str = \".\")",
            "index_workspace": {
              "signature": "(self, workspace_name: Optional[str] = None, **kwargs) -> Dict",
              "called_by": [
                "main",
                "index_workspace",
                "WorkspaceIndexer.index_all_workspaces"
              ]
            },
            "index_monorepo": {
              "signature": "(self, force: bool = False, selective: Optional[List[str]] = None, **kwargs) -> Dict",
              "called_by": [
                "main",
                "MonorepoCommands.migrate"
              ]
            },
            "interactive_config": {
              "signature": "(self, **kwargs) -> Dict",
              "called_by": [
                "main"
              ]
            },
            "status": {
              "signature": "(self, **kwargs) -> Dict",
              "called_by": [
                "main"
              ]
            },
            "stats": {
              "signature": "(self, **kwargs) -> Dict",
              "called_by": [
                "main"
              ]
            },
            "dependencies": {
              "signature": "(self, format: str = \"text\", **kwargs) -> Dict",
              "called_by": [
                "main"
              ]
            },
            "migrate": {
              "calls": [
                "index_monorepo"
              ],
              "signature": "(self, **kwargs) -> Dict",
              "called_by": [
                "main"
              ]
            }
          },
          "doc": "Main command handler for monorepo operations.",
          "properties": [
            "workspace_name",
            "force",
            "selective",
            "format",
            "else"
          ]
        }
      },
      "call_graph": {}
    },
    "scripts/project-index-helper.sh": {
      "language": "shell",
      "parsed": false,
      "purpose": "Utility functions"
    },
    "scripts/performance_monitor.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "time",
        "pathlib",
        "datetime",
        "typing",
        "dataclasses",
        "collections",
        "threading",
        "os",
        "psutil",
        "sys"
      ],
      "functions": {
        "get_performance_monitor": {
          "doc": "Get the global performance monitor instance.",
          "signature": "() -> PerformanceMonitor"
        },
        "performance_timing": {
          "doc": "Decorator for timing hook operations.",
          "calls": [
            "decorator",
            "end_hook_timing",
            "record_error",
            "start_hook_timing",
            "wrapper"
          ],
          "signature": "(hook_name: str, operation: str = \"unknown\")"
        }
      },
      "classes": {
        "HookTiming": {
          "methods": {
            "to_dict": {
              "signature": "(self) -> Dict",
              "called_by": [
                "WorkspaceRegistry.to_dict",
                "PerformanceMonitor._log_performance_data",
                "detect_monorepo"
              ]
            }
          },
          "decorators": [
            "dataclass"
          ],
          "doc": "Track timing data for hook executions.",
          "properties": [
            "hook_name",
            "start_time",
            "end_time",
            "duration",
            "workspace",
            "file_path",
            "operation",
            "success",
            "error_message"
          ]
        },
        "CacheStats": {
          "methods": {
            "to_dict": {
              "signature": "(self) -> Dict",
              "called_by": [
                "WorkspaceRegistry.to_dict",
                "PerformanceMonitor._log_performance_data",
                "detect_monorepo"
              ]
            }
          },
          "decorators": [
            "dataclass"
          ],
          "doc": "Track cache performance statistics.",
          "properties": [
            "cache_name",
            "hits",
            "misses",
            "evictions",
            "size",
            "max_size",
            "hit_rate"
          ]
        },
        "ResourceUsage": {
          "methods": {
            "to_dict": {
              "signature": "(self) -> Dict",
              "called_by": [
                "WorkspaceRegistry.to_dict",
                "PerformanceMonitor._log_performance_data",
                "detect_monorepo"
              ]
            }
          },
          "decorators": [
            "dataclass"
          ],
          "doc": "Track system resource usage during operations.",
          "properties": [
            "timestamp",
            "cpu_percent",
            "memory_mb",
            "disk_io_read",
            "disk_io_write",
            "process_id"
          ]
        },
        "PerformanceMonitor": {
          "methods": {
            "__init__": "(self)",
            "set_performance_log_path": {
              "doc": "Set the path for performance logging.",
              "signature": "(self, project_root: Path)"
            },
            "start_hook_timing": {
              "doc": "Start timing a hook operation.",
              "calls": [
                "_record_resource_usage"
              ],
              "signature": "(self, hook_name: str, operation: str, workspace: Optional[str] = None, file_path: Optional[str] = None) -> str",
              "called_by": [
                "performance_timing"
              ]
            },
            "end_hook_timing": {
              "doc": "End timing a hook operation and record performance data.",
              "calls": [
                "_check_performance_thresholds",
                "_log_performance_data",
                "_record_resource_usage"
              ],
              "signature": "(self, timing_id: str, success: bool = True, error_message: Optional[str] = None)",
              "called_by": [
                "performance_timing"
              ]
            },
            "record_cache_hit": {
              "doc": "Record a cache hit.",
              "signature": "(self, cache_name: str)"
            },
            "record_cache_miss": {
              "doc": "Record a cache miss.",
              "signature": "(self, cache_name: str)"
            },
            "record_cache_eviction": {
              "doc": "Record a cache eviction.",
              "signature": "(self, cache_name: str)"
            },
            "record_error": {
              "doc": "Record an error occurrence.",
              "signature": "(self, error_type: str)",
              "called_by": [
                "performance_timing"
              ]
            },
            "get_performance_summary": {
              "doc": "Get performance summary for the last N hours.",
              "calls": [
                "_get_cache_statistics",
                "_get_hook_breakdown",
                "_get_workspace_breakdown",
                "_percentile"
              ],
              "signature": "(self, hours: int = 24) -> Dict"
            },
            "optimize_caches": {
              "doc": "Analyze and optimize cache configurations.",
              "signature": "(self, project_root: Path) -> Dict"
            },
            "_record_resource_usage": {
              "doc": "Record current resource usage.",
              "signature": "(self)",
              "called_by": [
                "PerformanceMonitor.end_hook_timing",
                "PerformanceMonitor.start_hook_timing"
              ]
            },
            "_check_performance_thresholds": {
              "doc": "Check if performance thresholds are violated.",
              "signature": "(self, timing: HookTiming)",
              "called_by": [
                "PerformanceMonitor.end_hook_timing"
              ]
            },
            "_log_performance_data": {
              "doc": "Log performance data to file.",
              "calls": [
                "to_dict"
              ],
              "signature": "(self, timing: HookTiming)",
              "called_by": [
                "PerformanceMonitor.end_hook_timing"
              ]
            },
            "_percentile": {
              "doc": "Calculate percentile of values.",
              "signature": "(self, values: List[float], percentile: float) -> float",
              "called_by": [
                "PerformanceMonitor.get_performance_summary",
                "PerformanceMonitor._get_hook_breakdown"
              ]
            },
            "_get_hook_breakdown": {
              "doc": "Get performance breakdown by hook type.",
              "calls": [
                "_percentile"
              ],
              "signature": "(self, timings: List[HookTiming]) -> Dict",
              "called_by": [
                "PerformanceMonitor.get_performance_summary"
              ]
            },
            "_get_workspace_breakdown": {
              "doc": "Get performance breakdown by workspace.",
              "signature": "(self, timings: List[HookTiming]) -> Dict",
              "called_by": [
                "PerformanceMonitor.get_performance_summary"
              ]
            },
            "_get_cache_statistics": {
              "doc": "Get cache performance statistics.",
              "signature": "(self) -> Dict",
              "called_by": [
                "PerformanceMonitor.get_performance_summary"
              ]
            }
          },
          "doc": "Central performance monitoring and optimization system."
        }
      },
      "call_graph": {}
    },
    "scripts/update_index.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "find_project_modules": {
          "doc": "Find project modules (index_utils, workspace_config, etc.) in project or system location.",
          "signature": "()"
        },
        "get_workflow_orchestrator": {
          "doc": "Get or create workflow orchestrator for the project.",
          "signature": "(project_root: Path) -> Optional['TaskWorkflowOrchestrator']"
        },
        "enable_workflow_integration": {
          "doc": "Enable workflow integration for the current update session.",
          "calls": [
            "get_workflow_orchestrator"
          ],
          "signature": "(project_root: Path, context: Optional[Dict] = None) -> bool"
        },
        "trigger_workflow_hook": {
          "doc": "Trigger a workflow integration hook if workflow is enabled.",
          "calls": [
            "trigger_workflow_hook"
          ],
          "signature": "(hook_name: str, **kwargs)"
        },
        "get_workspace_config_cached": {
          "doc": "Get workspace configuration with caching.",
          "signature": "(project_root: Path) -> Optional[Dict]"
        },
        "get_workspace_for_file": {
          "doc": "Determine which workspace a file belongs to.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(file_path: Path, project_root: Path) -> Optional[str]"
        },
        "get_workspace_index_path": {
          "doc": "Get the path to a workspace's index file.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> Optional[Path]"
        },
        "get_dependent_workspaces": {
          "doc": "Get list of workspaces that depend on the given workspace.",
          "calls": [
            "get_workspace_config_cached"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> List[str]"
        },
        "update_workspace_index": {
          "doc": "Update a specific workspace index.",
          "calls": [
            "get_workspace_index_path",
            "update_file_in_index"
          ],
          "signature": "(workspace_name: str, file_path: Path, project_root: Path) -> bool"
        },
        "handle_cross_workspace_dependencies": {
          "doc": "Handle cascade updates for dependent workspaces with enhanced analysis.",
          "calls": [
            "get_workspace_config_cached",
            "handle_basic_cross_workspace_dependencies",
            "update_root_index_dependencies",
            "update_workspace_dependencies"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> None"
        },
        "handle_basic_cross_workspace_dependencies": {
          "doc": "Basic cross-workspace dependency handling (fallback).",
          "calls": [
            "get_dependent_workspaces",
            "get_workspace_index_path"
          ],
          "signature": "(workspace_name: str, project_root: Path) -> None"
        },
        "update_root_index_dependencies": {
          "doc": "Update the root index with enhanced cross-workspace dependency information.",
          "signature": "(project_root: Path, cross_workspace_results: Dict) -> None"
        },
        "update_workspace_dependencies": {
          "doc": "Update a workspace index with enhanced dependency information.",
          "calls": [
            "get_workspace_index_path"
          ],
          "signature": "(workspace_name: str, project_root: Path, workspace_deps: Dict) -> None"
        },
        "update_root_index_workspace_registry": {
          "doc": "Update the root index workspace registry when workspace relationships change.",
          "calls": [
            "get_workspace_config_cached",
            "get_workspace_index_path"
          ],
          "signature": "(project_root: Path) -> None"
        },
        "update_file_in_index": {
          "doc": "Update a single file's entry in the enhanced index.",
          "signature": "(index_path: str, file_path: str, project_root: str) -> bool"
        },
        "detect_file_move": {
          "doc": "Detect if this is a cross-workspace file move by checking for stale entries.",
          "calls": [
            "get_workspace_config_cached",
            "get_workspace_for_file",
            "get_workspace_index_path"
          ],
          "signature": "(file_path: Path, project_root: Path) -> Optional[Dict]"
        },
        "handle_cross_workspace_file_move": {
          "doc": "Handle a file that has moved between workspaces.",
          "calls": [
            "get_workspace_index_path",
            "handle_cross_workspace_dependencies",
            "update_root_index_workspace_registry"
          ],
          "signature": "(move_info: Dict, project_root: Path) -> None"
        },
        "handle_file_update": {
          "decorators": [
            "performance_timing"
          ],
          "doc": "Handle a file update with workspace awareness and workflow integration.",
          "calls": [
            "detect_file_move",
            "enable_workflow_integration",
            "get_workspace_config_cached",
            "get_workspace_for_file",
            "handle_cross_workspace_dependencies",
            "handle_cross_workspace_file_move",
            "trigger_workflow_hook",
            "update_file_in_index",
            "update_root_index_workspace_registry",
            "update_workspace_index"
          ],
          "signature": "(file_path: Path, project_root: Path) -> None"
        },
        "main": {
          "doc": "Process PostToolUse hook input and update index with workspace awareness.",
          "calls": [
            "handle_file_update"
          ],
          "signature": "()"
        }
      },
      "classes": {},
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:00:31.627989"
    },
    "scripts/run_python.sh": {
      "language": "shell",
      "parsed": false
    },
    "scripts/find_python.sh": {
      "language": "shell",
      "parsed": true,
      "functions": {
        "find_python": "()"
      },
      "call_graph": {}
    },
    "scripts/workspace_indexer.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "index_workspace": {
          "calls": [
            "index_workspace"
          ],
          "signature": "(root_path: Union[str, Path], workspace_name: str) -> Optional[Dict]"
        },
        "index_all_workspaces": {
          "calls": [
            "index_all_workspaces"
          ],
          "signature": "(root_path: Union[str, Path]) -> Dict[str, Dict]"
        }
      },
      "classes": {
        "CrossWorkspaceDependencyAnalyzer": {
          "methods": {
            "__init__": {
              "calls": [
                "_load_workspace_packages"
              ],
              "signature": "(self, registry: WorkspaceRegistry)"
            },
            "_load_workspace_packages": {
              "doc": "Load package.json from each workspace to understand package names.",
              "signature": "(self) -> Dict[str, Dict]"
            },
            "get_workspace_dependencies": {
              "doc": "Get comprehensive dependency information for a workspace.",
              "calls": [
                "analyze_file_imports"
              ],
              "signature": "(self, workspace_name: str) -> Dict[str, List[str]]"
            },
            "analyze_file_imports": {
              "doc": "Analyze imports in a file to find cross-workspace dependencies.",
              "calls": [
                "_analyze_javascript_imports",
                "_analyze_package_json_deps",
                "_analyze_python_imports"
              ],
              "signature": "(self, file_path: Path, workspace: WorkspaceConfig) -> List[str]"
            },
            "_analyze_python_imports": {
              "doc": "Analyze Python imports for cross-workspace dependencies.",
              "calls": [
                "_resolve_python_import_to_workspace"
              ],
              "signature": "(self, content: str, workspace: WorkspaceConfig) -> List[str]"
            },
            "_analyze_javascript_imports": {
              "doc": "Analyze JavaScript/TypeScript imports for cross-workspace dependencies.",
              "calls": [
                "_resolve_javascript_import_to_workspace"
              ],
              "signature": "(self, content: str, workspace: WorkspaceConfig) -> List[str]"
            },
            "_analyze_package_json_deps": {
              "doc": "Analyze package.json dependencies for cross-workspace dependencies.",
              "signature": "(self, content: str, workspace: WorkspaceConfig) -> List[str]"
            },
            "_resolve_python_import_to_workspace": {
              "doc": "Resolve a Python import to a workspace name.",
              "signature": "(self, import_path: str, current_workspace: WorkspaceConfig) -> Optional[str]"
            },
            "_resolve_javascript_import_to_workspace": {
              "doc": "Resolve a JavaScript/TypeScript import to a workspace name.",
              "signature": "(self, import_path: str, current_workspace: WorkspaceConfig) -> Optional[str]"
            }
          }
        },
        "WorkspaceIndexer": {
          "methods": {
            "__init__": "(self, registry: WorkspaceRegistry, workflow_integration: bool = False)",
            "register_workflow_hook": "(self, hook_name: str, callback: callable)",
            "trigger_workflow_hook": "(self, hook_name: str, **kwargs)",
            "set_task_context": "(self, context: Dict[str, any])",
            "get_task_context": {
              "doc": "Get current task context.",
              "signature": "(self) -> Dict[str, any]"
            },
            "index_workspace": {
              "calls": [
                "_build_workspace_dependency_graph",
                "_generate_workspace_tree",
                "_matches_ignore_patterns",
                "_parse_file_content",
                "analyze_file_imports",
                "get_task_context",
                "get_workspace_dependencies",
                "trigger_workflow_hook"
              ],
              "signature": "(self, workspace_name: str) -> Optional[Dict]"
            },
            "_matches_ignore_patterns": {
              "doc": "Check if a file path matches any ignore pattern.",
              "signature": "(self, file_path: str, patterns: Set[str]) -> bool"
            },
            "_generate_workspace_tree": {
              "doc": "Generate ASCII tree structure for workspace.",
              "calls": [
                "add_tree_level"
              ],
              "signature": "(self, workspace_path: Path, workspace_root: str) -> List[str]"
            },
            "add_tree_level": {
              "calls": [
                "add_tree_level"
              ],
              "signature": "(path: Path, prefix: str = \"\", depth: int = 0, max_depth: int = 3)"
            },
            "_parse_file_content": {
              "doc": "Parse file content based on its extension.",
              "signature": "(self, content: str, file_extension: str) -> Optional[Dict]"
            },
            "_build_workspace_dependency_graph": {
              "doc": "Build dependency graph for the workspace.",
              "signature": "(self, files: Dict) -> Dict"
            },
            "index_all_workspaces": {
              "doc": "Index all workspaces in the registry.",
              "calls": [
                "index_workspace"
              ],
              "signature": "(self) -> Dict[str, Dict]"
            }
          },
          "doc": "Indexes individual workspaces with cross-workspace awareness and workflow integration.",
          "properties": [
            "hook_name",
            "callback",
            "hook_name",
            "context",
            "workspace_name"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T09:56:34.376225"
    },
    "examples/nx_example/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/nx.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/lerna.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/.project-index-config.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    "examples/pnpm_example/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/services/worker/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/services/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/apps/dashboard/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/apps/frontend/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/packages/database/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/packages/common/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/pnpm_example/packages/auth/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/shared/types/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/shared/utils/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/frontend/web/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/frontend/mobile/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/tools/cli/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/backend/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/manual_config_example/backend/auth/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/apps/web/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/apps/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/packages/core/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/packages/ui/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/lerna_example/packages/utils/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/apps/admin/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/apps/mobile/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/packages/web/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/packages/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "examples/nx_example/packages/shared/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/pnpm_workspaces/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/rush_monorepo/rush.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/yarn_workspaces/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/manual_config/.project-index-config.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    "tests/fixtures/nx_monorepo/expected_detection.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/nx_monorepo/nx.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/lerna_monorepo/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/lerna_monorepo/expected_detection.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/lerna_monorepo/lerna.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/lerna_monorepo/packages/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/nx_monorepo/packages/web/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/nx_monorepo/packages/api/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/nx_monorepo/packages/shared/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/nx_monorepo/packages/shared/src/index.ts": {
      "language": "typescript",
      "parsed": true,
      "purpose": "Application entry point",
      "imports": [
        "lodash"
      ],
      "functions": {
        "validateUser": "(userData: any): userData is User",
        "formatUserName": "(user: User): string"
      },
      "classes": {},
      "constants": {
        "API_ENDPOINTS": "collection"
      },
      "interfaces": {
        "User": {}
      },
      "call_graph": {}
    },
    "tests/fixtures/nx_monorepo/packages/api/src/index.ts": {
      "language": "typescript",
      "parsed": false,
      "purpose": "Application entry point"
    },
    "tests/fixtures/manual_config/projects/app/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/yarn_workspaces/packages/frontend/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/rush_monorepo/apps/website/package.json": {
      "language": "json",
      "parsed": false
    },
    "tests/fixtures/pnpm_workspaces/packages/core/package.json": {
      "language": "json",
      "parsed": false
    },
    ".agent/logs/2025-08-18.json": {
      "language": "json",
      "parsed": false
    },
    ".agent/logs/2025-08-19.json": {
      "language": "json",
      "parsed": false
    },
    "scripts/integration_worker_phase2.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "create_integration_orchestrator": "(root_path: Union[str, Path], max_workers: Optional[int] = None) -> TaskWorkflowOrchestrator",
        "execute_integration_workflow": {
          "calls": [
            "create_integration_orchestrator",
            "execute_workflow",
            "shutdown"
          ],
          "signature": "(root_path: Union[str, Path], target_workspaces: Optional[List[str]] = None, workflow_name: str = \"integration\", max_workers: Optional[int] = None) -> Dict[str, Any]"
        }
      },
      "classes": {
        "IntegrationTask": {
          "methods": {},
          "decorators": [
            "dataclass"
          ],
          "doc": "Enhanced task representation for the integration workflow system.",
          "properties": [
            "task_id",
            "task_type",
            "workspace_name",
            "priority",
            "dependencies",
            "workspace_dependencies",
            "estimated_duration",
            "max_retries",
            "retry_delay",
            "timeout",
            "metadata",
            "status",
            "created_at",
            "started_at",
            "completed_at",
            "retry_count",
            "error_message",
            "result"
          ]
        },
        "WorkflowProgress": {
          "methods": {
            "percentage_complete": {
              "decorators": [
                "property"
              ],
              "doc": "Calculate completion percentage.",
              "signature": "(self) -> float"
            },
            "elapsed_time": {
              "decorators": [
                "property"
              ],
              "doc": "Calculate elapsed time.",
              "signature": "(self) -> timedelta"
            }
          },
          "doc": "Extended progress tracking for multi-stage workflows.",
          "properties": [
            "total_tasks",
            "completed_tasks",
            "failed_tasks",
            "running_tasks",
            "queued_tasks",
            "task_results",
            "start_time",
            "stage"
          ]
        },
        "TaskWorkflowOrchestrator": {
          "methods": {
            "__init__": "(self, registry: WorkspaceRegistry, max_workers: Optional[int] = None, memory_limit_mb: int = 200, enable_caching: bool = True)",
            "add_workflow_callback": {
              "doc": "Add a callback function to receive workflow progress updates.",
              "signature": "(self, callback: Callable[[WorkflowProgress], None])"
            },
            "_notify_workflow_progress": {
              "doc": "Notify all workflow callbacks of updates.",
              "signature": "(self)"
            },
            "_estimate_task_duration": "(self, task: IntegrationTask) -> float",
            "create_task": {
              "calls": [
                "_estimate_task_duration"
              ],
              "signature": "(self, task_type: Union[TaskType, str], workspace_name: Optional[str] = None, priority: int = 0, dependencies: Optional[Set[str]] = None, workspace_dependencies: Optional[Set[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> str"
            },
            "_can_execute_task": "(self, task: IntegrationTask) -> bool",
            "_queue_ready_tasks": {
              "doc": "Queue tasks that are ready for execution.",
              "calls": [
                "_can_execute_task"
              ],
              "signature": "(self)"
            },
            "_execute_task": {
              "decorators": [
                "performance_timing"
              ],
              "calls": [
                "_cleanup_caches",
                "_validate_index_integrity"
              ],
              "signature": "(self, task: IntegrationTask) -> Any"
            },
            "_validate_index_integrity": {
              "doc": "Validate the integrity of workspace indexes.",
              "signature": "(self, workspace_name: Optional[str]) -> Dict[str, Any]"
            },
            "_cleanup_caches": {
              "doc": "Clean up stale cache entries.",
              "signature": "(self) -> Dict[str, Any]"
            },
            "execute_workflow": {
              "decorators": [
                "performance_timing"
              ],
              "calls": [
                "_all_tasks_completed",
                "_create_workflow_tasks",
                "_execute_task",
                "_notify_workflow_progress",
                "_queue_ready_tasks"
              ],
              "signature": "(self, workflow_name: str = \"default\", target_workspaces: Optional[List[str]] = None, include_cross_analysis: bool = True) -> Dict[str, Any]"
            },
            "_create_workflow_tasks": {
              "doc": "Create tasks for a complete workflow.",
              "calls": [
                "create_task"
              ],
              "signature": "(self, target_workspaces: Optional[List[str]], include_cross_analysis: bool) -> List[str]"
            },
            "_all_tasks_completed": {
              "doc": "Check if all tasks have completed.",
              "signature": "(self) -> bool"
            },
            "get_task_status": {
              "doc": "Get detailed status of a specific task.",
              "signature": "(self, task_id: str) -> Optional[Dict[str, Any]]"
            },
            "shutdown": {
              "doc": "Request graceful shutdown of the orchestrator.",
              "calls": [
                "shutdown"
              ],
              "signature": "(self)"
            }
          },
          "properties": [
            "registry",
            "max_workers",
            "memory_limit_mb",
            "enable_caching",
            "task",
            "task_type",
            "workspace_name",
            "priority",
            "dependencies",
            "workspace_dependencies",
            "metadata",
            "task",
            "task",
            "workflow_name",
            "target_workspaces",
            "include_cross_analysis"
          ]
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:06:18.374590"
    },
    "scripts/test_monorepo_integration.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "main": {
          "doc": "Run the monorepo integration test suite.",
          "calls": [
            "run_all_tests"
          ],
          "signature": "()"
        }
      },
      "classes": {
        "MonorepoIntegrationTester": {
          "methods": {
            "__init__": "(self, examples_dir: Path)",
            "run_all_tests": {
              "doc": "Run tests for all supported monorepo types.",
              "calls": [
                "print_summary",
                "test_monorepo_type"
              ],
              "signature": "(self) -> Dict[str, Dict]"
            },
            "test_monorepo_type": {
              "doc": "Test a specific monorepo type.",
              "signature": "(self, monorepo_type: str, example_path: Path) -> Dict"
            },
            "print_summary": {
              "doc": "Print test results summary.",
              "signature": "(self)"
            }
          },
          "doc": "Test suite for monorepo integration compatibility."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:04:29.817597",
      "purpose": "Test file"
    },
    "scripts/performance_validator.py": {
      "language": "python",
      "parsed": true,
      "functions": {
        "main": {
          "doc": "Main entry point for performance validation.",
          "calls": [
            "run_all_performance_tests"
          ],
          "signature": "()"
        }
      },
      "classes": {
        "PerformanceResult": {
          "methods": {
            "__init__": "(self, name: str, passed: bool, measured_value: float, threshold: float, unit: str = \"\", details: Optional[Dict] = None)",
            "to_dict": "(self) -> Dict"
          },
          "doc": "Represents the result of a performance test."
        },
        "PerformanceValidator": {
          "methods": {
            "__init__": "(self, root_path: Path)",
            "memory_monitor": {
              "decorators": [
                "contextmanager"
              ],
              "doc": "Context manager to monitor peak memory usage during operation.",
              "calls": [
                "monitor_memory"
              ],
              "signature": "(self, timeout: float = 60.0)"
            },
            "monitor_memory": "()",
            "timeout_guard": {
              "decorators": [
                "contextmanager"
              ],
              "doc": "Context manager to prevent infinite loops by enforcing timeouts.",
              "calls": [
                "timeout_handler"
              ],
              "signature": "(self, timeout_seconds: float, operation_name: str)"
            },
            "timeout_handler": "()",
            "test_root_index_generation_time": {
              "doc": "Test: Root index generation must complete in <30 seconds.",
              "calls": [
                "timeout_guard"
              ],
              "signature": "(self) -> PerformanceResult"
            },
            "test_root_index_file_size": {
              "doc": "Test: Root index file size must be <200KB.",
              "signature": "(self) -> PerformanceResult"
            },
            "test_workspace_loading_time": {
              "doc": "Test: Workspace loading must complete in <2 seconds per workspace.",
              "signature": "(self) -> PerformanceResult"
            },
            "test_memory_usage_large_monorepo": {
              "doc": "Test: Memory usage must stay <500MB for large operations.",
              "calls": [
                "memory_monitor",
                "timeout_guard"
              ],
              "signature": "(self) -> PerformanceResult"
            },
            "test_no_infinite_loops": {
              "doc": "Test: All operations must terminate (no infinite loops).",
              "calls": [
                "timeout_guard"
              ],
              "signature": "(self) -> PerformanceResult"
            },
            "run_all_performance_tests": {
              "doc": "Run all performance validation tests and return comprehensive results.",
              "calls": [
                "test_memory_usage_large_monorepo",
                "test_no_infinite_loops",
                "test_root_index_file_size",
                "test_root_index_generation_time",
                "test_workspace_loading_time",
                "to_dict"
              ],
              "signature": "(self) -> Dict"
            }
          },
          "doc": "Validates performance requirements for the hierarchical indexing architecture."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:43:21.682084"
    },
    "tests/test_hierarchical_indexer.py": {
      "language": "python",
      "parsed": true,
      "functions": {},
      "classes": {
        "TestHierarchicalIndexManager": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_manager_initialization": {
              "doc": "Test HierarchicalIndexManager initialization.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_detect_project_type_single_repo": {
              "doc": "Test project type detection for single repository.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_detect_project_type_monorepo_nx": {
              "doc": "Test project type detection for Nx monorepo.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_detect_project_type_manual_config_enabled": {
              "doc": "Test manual configuration override enabling monorepo.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_detect_project_type_manual_config_disabled": {
              "doc": "Test manual configuration override disabling monorepo.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_single_repo_index": {
              "doc": "Test single-repo index generation.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_monorepo_index_basic": {
              "doc": "Test basic monorepo index generation.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_monorepo_index_with_workspace_indexes": {
              "doc": "Test monorepo index generation with existing workspace indexes.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_monorepo_index_with_cross_dependencies": {
              "doc": "Test monorepo index generation with cross-workspace dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_validate_generation_constraints_time_limit": {
              "doc": "Test validation of generation time constraint.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_validate_generation_constraints_size_limit": {
              "doc": "Test validation of index size constraint.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_validate_generation_constraints_success": {
              "doc": "Test successful validation of generation constraints.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_save_root_index_default_path": {
              "doc": "Test saving root index to default location.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_save_root_index_custom_path": {
              "doc": "Test saving root index to custom location.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_force_monorepo_override": {
              "doc": "Test force monorepo override for single-repo project.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_workspace_overview_tree_generation": {
              "doc": "Test generation of workspace overview tree.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_error_handling_missing_dependencies": {
              "doc": "Test graceful handling of missing dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_performance_with_large_workspace_count": {
              "doc": "Test performance with many workspaces.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the HierarchicalIndexManager class."
        },
        "TestGenerateHierarchicalIndexFunction": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_generate_hierarchical_index_function_single_repo": {
              "doc": "Test the main function with single repo.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_hierarchical_index_function_monorepo": {
              "doc": "Test the main function with monorepo.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_generate_hierarchical_index_function_force_monorepo": {
              "doc": "Test the main function with force_monorepo flag.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the main generate_hierarchical_index function."
        },
        "TestEdgeCasesAndErrorHandling": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_malformed_workspace_index_handling": {
              "doc": "Test handling of malformed workspace index files.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_missing_workspace_directories": {
              "doc": "Test handling of workspaces with missing directories.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_circular_workspace_dependencies_handling": {
              "doc": "Test handling of circular workspace dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_empty_monorepo_configuration": {
              "doc": "Test handling of empty monorepo configuration.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test edge cases and error handling scenarios."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:53:25.222955",
      "purpose": "Test file"
    },
    "tests/test_lazy_index_loader.py": {
      "language": "python",
      "parsed": true,
      "functions": {},
      "classes": {
        "TestCacheEntry": {
          "methods": {
            "test_cache_entry_creation": {
              "doc": "Test CacheEntry initialization.",
              "signature": "(self)"
            },
            "test_cache_entry_access": {
              "doc": "Test cache entry access counting.",
              "signature": "(self)"
            },
            "test_cache_entry_staleness_fresh": {
              "doc": "Test staleness detection for fresh entries.",
              "signature": "(self)"
            },
            "test_cache_entry_staleness_stale": {
              "doc": "Test staleness detection for stale entries.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the CacheEntry class."
        },
        "TestLRUCache": {
          "methods": {
            "setUp": {
              "doc": "Set up test cache.",
              "signature": "(self)"
            },
            "test_cache_initialization": {
              "doc": "Test cache initialization.",
              "signature": "(self)"
            },
            "test_cache_put_and_get": {
              "doc": "Test basic cache put and get operations.",
              "signature": "(self)"
            },
            "test_cache_put_with_custom_size": {
              "doc": "Test cache put with custom size estimation.",
              "signature": "(self)"
            },
            "test_cache_eviction_by_count": {
              "doc": "Test cache eviction when max entries exceeded.",
              "signature": "(self)"
            },
            "test_cache_eviction_by_size": {
              "doc": "Test cache eviction when max size exceeded.",
              "signature": "(self)"
            },
            "test_cache_lru_ordering": {
              "doc": "Test LRU (Least Recently Used) ordering.",
              "signature": "(self)"
            },
            "test_cache_staleness_handling": {
              "doc": "Test cache staleness detection and removal.",
              "signature": "(self)"
            },
            "test_cache_invalidation": {
              "doc": "Test explicit cache invalidation.",
              "signature": "(self)"
            },
            "test_cache_invalidate_pattern": {
              "doc": "Test pattern-based cache invalidation.",
              "signature": "(self)"
            },
            "test_cache_clear": {
              "doc": "Test cache clearing.",
              "signature": "(self)"
            },
            "test_cache_stats": {
              "doc": "Test cache statistics.",
              "signature": "(self)"
            },
            "test_cache_thread_safety": {
              "doc": "Test cache thread safety.",
              "calls": [
                "worker"
              ],
              "signature": "(self)"
            },
            "worker": "(thread_id)"
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the LRUCache class."
        },
        "TestLazyIndexLoader": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_loader_initialization": {
              "doc": "Test LazyIndexLoader initialization.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_success": {
              "doc": "Test successful root index loading.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_file_not_found": {
              "doc": "Test root index loading when file doesn't exist.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_malformed_json": {
              "doc": "Test root index loading with malformed JSON.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_caching": {
              "doc": "Test root index caching behavior.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_force_refresh": {
              "doc": "Test forcing root index refresh bypasses cache.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_success": {
              "doc": "Test successful workspace index loading.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_not_found": {
              "doc": "Test workspace index loading when workspace not found.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_file_missing": {
              "doc": "Test workspace index loading when index file is missing.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_caching": {
              "doc": "Test workspace index caching behavior.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_get_workspace_dependencies": {
              "doc": "Test workspace dependency retrieval.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_get_workspace_dependents": {
              "doc": "Test workspace dependents retrieval.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_invalidate_workspace": {
              "doc": "Test workspace cache invalidation.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_invalidate_root_index": {
              "doc": "Test root index cache invalidation.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_cache_stats": {
              "doc": "Test cache statistics retrieval.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_file_staleness_detection": {
              "doc": "Test file modification time tracking for staleness.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the LazyIndexLoader class."
        },
        "TestGlobalLoaderFunctions": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_get_global_loader_singleton": {
              "doc": "Test that get_global_loader returns singleton instances.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_root_index_function": {
              "doc": "Test the load_root_index convenience function.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_function": {
              "doc": "Test the load_workspace_index convenience function.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_load_workspace_index_function_not_found": {
              "doc": "Test workspace index function with non-existent workspace.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test global loader functions."
        },
        "TestPerformanceAndEdgeCases": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_large_index_loading_performance": {
              "doc": "Test performance with large index files.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_memory_usage_with_many_workspaces": {
              "doc": "Test memory behavior with many cached workspaces.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_concurrent_access_safety": {
              "doc": "Test thread safety with concurrent access.",
              "calls": [
                "concurrent_loader",
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "concurrent_loader": "(thread_id)",
            "test_error_recovery_corrupted_cache": {
              "doc": "Test recovery from corrupted cache state.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test performance characteristics and edge cases."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:51:01.235753",
      "purpose": "Test file"
    },
    "tests/test_smart_compressor.py": {
      "language": "python",
      "parsed": true,
      "functions": {},
      "classes": {
        "TestCircularReferenceDetector": {
          "methods": {
            "setUp": {
              "doc": "Set up test detector.",
              "signature": "(self)"
            },
            "test_detector_initialization": {
              "doc": "Test CircularReferenceDetector initialization.",
              "signature": "(self)"
            },
            "test_detect_cycles_simple_object": {
              "doc": "Test cycle detection with simple objects.",
              "signature": "(self)"
            },
            "test_detect_cycles_nested_object": {
              "doc": "Test cycle detection with nested objects.",
              "signature": "(self)"
            },
            "test_detect_cycles_direct_circular_reference": {
              "doc": "Test detection of direct circular references.",
              "signature": "(self)"
            },
            "test_detect_cycles_indirect_circular_reference": {
              "doc": "Test detection of indirect circular references.",
              "signature": "(self)"
            },
            "test_detect_cycles_list_with_cycles": {
              "doc": "Test cycle detection in lists.",
              "signature": "(self)"
            },
            "test_detect_cycles_complex_structure": {
              "doc": "Test cycle detection in complex nested structures.",
              "signature": "(self)"
            },
            "test_create_reference_marker": {
              "doc": "Test reference marker creation.",
              "signature": "(self)"
            },
            "test_performance_with_large_structure": {
              "doc": "Test performance with large data structures.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the CircularReferenceDetector class."
        },
        "TestBatchProcessor": {
          "methods": {
            "setUp": {
              "doc": "Set up test processor.",
              "signature": "(self)"
            },
            "test_processor_initialization": {
              "doc": "Test BatchProcessor initialization.",
              "signature": "(self)"
            },
            "test_process_items_basic": {
              "doc": "Test basic item processing.",
              "calls": [
                "processor_func"
              ],
              "signature": "(self)"
            },
            "processor_func": "(key, value)",
            "test_process_items_with_batching": {
              "doc": "Test item processing with batching.",
              "calls": [
                "processor_func",
                "progress_callback"
              ],
              "signature": "(self)"
            },
            "progress_callback": "(processed, total, percent, description)",
            "test_process_dict_items": {
              "doc": "Test dictionary item processing.",
              "calls": [
                "processor_func"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the BatchProcessor class."
        },
        "TestSmartCompressor": {
          "methods": {
            "setUp": {
              "doc": "Set up test compressor.",
              "signature": "(self)"
            },
            "test_compressor_initialization": {
              "doc": "Test SmartCompressor initialization.",
              "signature": "(self)"
            },
            "test_compress_root_index_basic": {
              "doc": "Test basic root index compression.",
              "signature": "(self)"
            },
            "test_compress_workspace_index_basic": {
              "doc": "Test basic workspace index compression.",
              "signature": "(self)"
            },
            "test_compress_root_index_with_circular_dependencies": {
              "doc": "Test root index compression with circular dependencies.",
              "signature": "(self)"
            },
            "test_compress_workspace_index_remove_redundant_data": {
              "doc": "Test removal of redundant data in workspace compression.",
              "signature": "(self)"
            },
            "test_aggressive_compression_when_oversized": {
              "doc": "Test aggressive compression when size limits are exceeded.",
              "signature": "(self)"
            },
            "test_compression_statistics": {
              "doc": "Test compression statistics tracking.",
              "signature": "(self)"
            },
            "test_reset_compression_statistics": {
              "doc": "Test resetting compression statistics.",
              "signature": "(self)"
            },
            "test_file_entries_compression": {
              "doc": "Test specific file entries compression logic.",
              "signature": "(self)"
            },
            "test_dependency_graph_compression": {
              "doc": "Test dependency graph compression.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the SmartCompressor class."
        },
        "TestCompressIndexSafeFunction": {
          "methods": {
            "test_compress_index_safe_root_index": {
              "doc": "Test safe compression for root index.",
              "signature": "(self)"
            },
            "test_compress_index_safe_workspace_index": {
              "doc": "Test safe compression for workspace index.",
              "signature": "(self)"
            },
            "test_compress_index_safe_invalid_type": {
              "doc": "Test safe compression with invalid index type.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the compress_index_safe function."
        },
        "TestPerformanceAndEdgeCases": {
          "methods": {
            "setUp": {
              "doc": "Set up test compressor.",
              "signature": "(self)"
            },
            "test_performance_large_workspace_index": {
              "doc": "Test compression performance with large workspace index.",
              "signature": "(self)"
            },
            "test_memory_efficiency_repeated_compression": {
              "doc": "Test memory efficiency with repeated compressions.",
              "signature": "(self)"
            },
            "test_thread_safety_concurrent_compression": {
              "doc": "Test thread safety with concurrent compressions.",
              "calls": [
                "compress_worker"
              ],
              "signature": "(self)"
            },
            "compress_worker": "(thread_id)",
            "test_error_handling_malformed_data": {
              "doc": "Test error handling with malformed data.",
              "signature": "(self)"
            },
            "test_compression_ratio_calculation": {
              "doc": "Test compression ratio calculation accuracy.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test performance characteristics and edge cases."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:53:00.157760",
      "purpose": "Test file"
    },
    "tests/test_hierarchical_indexer_simple.py": {
      "language": "python",
      "parsed": true,
      "functions": {},
      "classes": {
        "TestHierarchicalIndexManagerBasic": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_manager_initialization_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test HierarchicalIndexManager initialization with mocked dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_detect_project_type_single_repo_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test project type detection for single repository with mocked dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager, mock_detect)"
            },
            "test_detect_project_type_monorepo_nx_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test project type detection for Nx monorepo with mocked dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager, mock_detect)"
            },
            "test_manual_config_override_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test manual configuration override with mocked dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_generate_single_repo_index_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test single-repo index generation with mocked dependencies.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_validate_generation_constraints_time_limit_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test validation of generation time constraint with mocked dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_validate_generation_constraints_size_limit_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test validation of index size constraint with mocked dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_save_root_index_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test saving root index with mocked dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            },
            "test_workspace_overview_tree_generation_with_mocks": {
              "decorators": [
                "patch",
                "patch",
                "patch"
              ],
              "doc": "Test generation of workspace overview tree with mocked dependencies.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_compressor, mock_loader, mock_workspace_manager)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test HierarchicalIndexManager with mocked dependencies."
        },
        "TestGenerateHierarchicalIndexFunctionMocked": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "test_generate_hierarchical_index_function_with_mocks": {
              "decorators": [
                "patch"
              ],
              "doc": "Test the main function with mocked HierarchicalIndexManager.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self, mock_manager_class)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Test the main generate_hierarchical_index function with mocked dependencies."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T10:54:22.808065",
      "purpose": "Test file"
    },
    "tests/test_monorepo_integration.py": {
      "language": "python",
      "parsed": true,
      "functions": {},
      "classes": {
        "TestMonorepoIntegrationBase": {
          "methods": {
            "setUp": {
              "doc": "Set up test environment.",
              "signature": "(self)"
            },
            "tearDown": {
              "doc": "Clean up test environment.",
              "signature": "(self)"
            },
            "create_temp_dir": {
              "doc": "Create a temporary directory for testing.",
              "signature": "(self)"
            },
            "create_file": {
              "doc": "Create a file with the given content.",
              "signature": "(self, path: Path, content: str)"
            },
            "create_workspace_package_json": {
              "doc": "Create a standard package.json for a workspace.",
              "calls": [
                "create_file"
              ],
              "signature": "(self, workspace_dir: Path, name: str, dependencies: dict = None)"
            },
            "validate_monorepo_detection": {
              "doc": "Validate that monorepo detection works correctly.",
              "signature": "(self, temp_dir: Path, expected_tool: str, min_workspaces: int = 1)"
            }
          },
          "inherits": [
            "unittest.TestCase"
          ],
          "doc": "Base class for monorepo integration tests."
        },
        "TestNxMonorepoIntegration": {
          "methods": {
            "test_nx_monorepo_basic_detection": {
              "doc": "Test basic Nx monorepo detection and indexing.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            },
            "test_nx_monorepo_with_legacy_workspace_json": {
              "doc": "Test Nx with legacy workspace.json configuration.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test Nx monorepo integration."
        },
        "TestLernaMonorepoIntegration": {
          "methods": {
            "test_lerna_monorepo_basic_detection": {
              "doc": "Test basic Lerna monorepo detection and indexing.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            },
            "test_lerna_monorepo_with_scoped_packages": {
              "doc": "Test Lerna with scoped package names.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test Lerna monorepo integration."
        },
        "TestPnpmMonorepoIntegration": {
          "methods": {
            "test_pnpm_monorepo_basic_detection": {
              "doc": "Test basic PNPM monorepo detection and indexing.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_pnpm_monorepo_with_catalog": {
              "doc": "Test PNPM with dependency catalog.",
              "calls": [
                "create_temp_dir"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test PNPM monorepo integration."
        },
        "TestYarnMonorepoIntegration": {
          "methods": {
            "test_yarn_workspaces_basic_detection": {
              "doc": "Test basic Yarn Workspaces detection and indexing.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            },
            "test_yarn_workspaces_object_syntax": {
              "doc": "Test Yarn Workspaces with object syntax.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test Yarn Workspaces integration."
        },
        "TestRushMonorepoIntegration": {
          "methods": {
            "test_rush_monorepo_basic_detection": {
              "doc": "Test basic Rush monorepo detection and indexing.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            },
            "test_rush_monorepo_with_pnpm": {
              "doc": "Test Rush monorepo with PNPM package manager.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test Rush monorepo integration."
        },
        "TestManualConfigurationIntegration": {
          "methods": {
            "test_manual_config_override_detection": {
              "doc": "Test manual configuration overriding automatic detection.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json"
              ],
              "signature": "(self)"
            },
            "test_manual_config_pattern_based": {
              "doc": "Test manual configuration with pattern-based workspace discovery.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test manual configuration override integration."
        },
        "TestMonorepoFixtureIntegration": {
          "methods": {
            "test_nx_fixture_integration": {
              "doc": "Test integration with Nx fixture if available.",
              "signature": "(self)"
            },
            "test_lerna_fixture_integration": {
              "doc": "Test integration with Lerna fixture if available.",
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test integration with existing fixture files."
        },
        "TestCrossToolCompatibility": {
          "methods": {
            "test_priority_handling_multiple_configs": {
              "doc": "Test priority handling when multiple monorepo configurations exist.",
              "calls": [
                "create_file",
                "create_temp_dir"
              ],
              "signature": "(self)"
            },
            "test_fallback_when_manual_disabled": {
              "doc": "Test fallback to automatic detection when manual config disabled.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test compatibility when multiple tool configurations exist."
        },
        "TestPerformanceWithLargeMonorepos": {
          "methods": {
            "test_performance_many_workspaces": {
              "doc": "Test detection performance with many workspaces.",
              "calls": [
                "create_file",
                "create_temp_dir",
                "create_workspace_package_json",
                "validate_monorepo_detection"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "TestMonorepoIntegrationBase"
          ],
          "doc": "Test performance with large monorepo configurations."
        }
      },
      "updated_by_hook": true,
      "updated_at": "2025-08-19T11:08:40.337082",
      "purpose": "Test file"
    }
  },
  "dependency_graph": {
    "run_coverage.py": [
      "sys",
      "subprocess",
      "time",
      "pathlib"
    ],
    "scripts/reindex_if_needed_enhanced.py": [
      "json",
      "sys",
      "os",
      "subprocess",
      "time",
      "pathlib",
      "datetime",
      "typing",
      "workspace_config",
      "workspace_indexer"
    ],
    "scripts/cross_workspace_analyzer.py": [
      "json",
      "re",
      "ast",
      "os",
      "pathlib",
      "typing",
      "collections",
      "dataclasses",
      "workspace_config",
      "sys",
      "workspace_config"
    ],
    "scripts/project_index.py": [
      "json",
      "os",
      "re",
      "datetime",
      "pathlib",
      "typing",
      "index_utils",
      "workspace_config",
      "workspace_indexer",
      "cross_workspace_analyzer",
      "hierarchical_indexer",
      "smart_compressor",
      "workspace_config",
      "workspace_indexer",
      "cross_workspace_analyzer",
      "sys"
    ],
    "scripts/lazy_index_loader.py": [
      "json",
      "os",
      "threading",
      "time",
      "collections",
      "datetime",
      "pathlib",
      "typing",
      "weakref",
      "hashlib",
      "sys",
      "pathlib",
      "hierarchical_indexer",
      "workspace_config",
      "argparse"
    ],
    "scripts/index_utils.py": [
      "re",
      "fnmatch",
      "pathlib",
      "typing"
    ],
    "scripts/update_index_enhanced.py": [
      "json",
      "sys",
      "os",
      "pathlib",
      "datetime",
      "typing",
      "time",
      "index_utils",
      "workspace_config",
      "workspace_indexer"
    ],
    "scripts/reindex_if_needed.py": [
      "json",
      "sys",
      "os",
      "subprocess",
      "time",
      "pathlib",
      "datetime",
      "typing",
      "workspace_config",
      "workspace_indexer"
    ],
    "scripts/detect_external_changes.py": [
      "os",
      "json",
      "subprocess",
      "pathlib",
      "datetime",
      "sys"
    ],
    "scripts/smart_compressor.py": [
      "json",
      "time",
      "gc",
      "typing",
      "collections",
      "threading",
      "weakref",
      "argparse"
    ],
    "scripts/monorepo_detector.py": [
      "json",
      "re",
      "yaml",
      "pathlib",
      "typing",
      "sys"
    ],
    "scripts/parallel_workspace_processor.py": [
      "json",
      "time",
      "threading",
      "concurrent.futures",
      "dataclasses",
      "datetime",
      "pathlib",
      "typing",
      "queue",
      "traceback",
      "os",
      "psutil",
      "workspace_config",
      "workspace_indexer",
      "cross_workspace_analyzer",
      "performance_monitor",
      "sys",
      "argparse"
    ],
    "scripts/workspace_config.py": [
      "json",
      "re",
      "pathlib",
      "typing",
      "datetime",
      "monorepo_detector",
      "sys"
    ],
    "scripts/hierarchical_indexer.py": [
      "json",
      "os",
      "time",
      "datetime",
      "pathlib",
      "typing",
      "sys",
      "pathlib",
      "workspace_config",
      "monorepo_detector",
      "smart_compressor",
      "argparse"
    ],
    "scripts/monorepo_commands.py": [
      "json",
      "sys",
      "time",
      "argparse",
      "pathlib",
      "typing",
      "datetime",
      "workspace_config",
      "parallel_workspace_processor",
      "performance_monitor",
      "project_index"
    ],
    "scripts/performance_monitor.py": [
      "json",
      "time",
      "pathlib",
      "datetime",
      "typing",
      "dataclasses",
      "collections",
      "threading",
      "os",
      "psutil",
      "sys"
    ],
    "scripts/update_index.py": [
      "json",
      "sys",
      "os",
      "pathlib",
      "datetime",
      "typing",
      "time",
      "performance_monitor",
      "index_utils",
      "workspace_config",
      "workspace_indexer",
      "cross_workspace_analyzer"
    ],
    "scripts/workspace_indexer.py": [
      "json",
      "re",
      "ast",
      "pathlib",
      "typing",
      "datetime",
      "workspace_config",
      "index_utils",
      "cross_workspace_analyzer",
      "sys"
    ],
    "tests/fixtures/nx_monorepo/packages/shared/src/index.ts": [
      "lodash"
    ]
  },
  "staleness_check": 1755006182.036487
}